<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deriv API Market Analysis Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #0f172a;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1e293b;
            --light: #f8fafc;
            --gray: #94a3b8;
            --card-bg: rgba(15, 23, 42, 0.7);
            --border: rgba(255, 255, 255, 0.1);
        }
        
        .strategy-list-item {
            /* display: flex; flex-direction: column; */
            /* margin-bottom: 10px; */ /* Gap is handled by flex container now */
        }
        .strategy-list-item h5 { /* Ensure consistent margin for the title */
            margin-top: 0;
            margin-bottom: 8px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo i {
            font-size: 28px;
            color: var(--primary);
        }
        
        .logo h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(to right, #3b82f6, #60a5fa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .currency-selector {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 15px;
            color: var(--light);
            font-weight: 500;
            min-width: 150px;
        }
        
        .btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }
        
        .btn-outline {
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        
        .btn-outline:hover {
            background: rgba(37, 99, 235, 0.1);
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .main-content {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 20px;
        }
        
        .chart-container {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 20px;
            height: 500px;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .chart-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .timeframe-selector {
            display: flex;
            gap: 10px;
        }
        
        .time-btn {
            background: transparent;
            color: var(--gray);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .time-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .indicators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .indicator-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            transition: transform 0.3s ease;
        }
        
        .indicator-card:hover {
            transform: translateY(-5px);
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        .indicator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .indicator-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .indicator-value {
            font-size: 24px;
            font-weight: 700;
        }
        
        .trend-up {
            color: var(--success);
        }
        
        .trend-down {
            color: var(--danger);
        }

        /* Styles for Market Sentiment value */
        .sentiment-value-bullish {
            background-color: rgba(34, 197, 94, 0.2); /* --success with alpha */
            color: var(--success);
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block; /* To allow padding and border-radius */
            font-weight: 600;
        }
        .sentiment-value-bearish {
            background-color: rgba(239, 68, 68, 0.2); /* --danger with alpha */
            color: var(--danger);
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block;
            font-weight: 600;
        }
        .sentiment-value-neutral {
            background-color: rgba(148, 163, 184, 0.2); /* --gray with alpha */
            color: var(--gray);
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block;
            font-weight: 600;
        }

        /* Styles for Prediction States */
        .prediction-state-text { /* Common styling for all prediction states */
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.9em;
            font-weight: 500;
            text-align: center;
            min-width: 80px; /* Ensure consistent width */
            display: inline-block;
        }
        .prediction-state-oversold { /* Bullish connotation */
            background-color: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }
        .prediction-state-overbought { /* Bearish connotation */
            background-color: rgba(239, 68, 68, 0.15);
            color: var(--danger);
        }
        .prediction-state-bullish {
            background-color: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }
        .prediction-state-bearish {
            background-color: rgba(239, 68, 68, 0.15);
            color: var(--danger);
        }
        .prediction-state-neutral {
            background-color: rgba(148, 163, 184, 0.15);
            color: var(--gray);
        }
        
        .indicator-chart {
            height: 100px;
            margin-top: 15px;
        }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .market-overview {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
        }
        
        .overview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .price-display {
            font-size: 32px;
            font-weight: 700;
            margin: 10px 0;
            background: linear-gradient(to right, #3b82f6, #60a5fa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .price-change {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .change-up {
            color: var(--success);
        }
        
        .change-down {
            color: var(--danger);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            margin: 5px 0;
        }
        
        .stat-label {
            color: var(--gray);
            font-size: 14px;
        }
        
        .prediction-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
        }
        
        .prediction-header {
            margin-bottom: 15px;
        }
        
        .prediction-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .prediction-item {
            display: flex;
            justify-content: space-between;
            align-items: center; /* Vertically align items in the center */
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }
        .prediction-item > div:first-child { /* Label RSI, MACD etc. */
            flex-basis: 35%; /* Give it more space */
            text-align: left;
            font-weight: 500;
        }
        .prediction-item > div:nth-child(2) { /* State Text e.g. Oversold */
            flex-basis: 30%; 
            text-align: center; /* The .prediction-state-text already centers its content */
        }
        .prediction-item > div:nth-child(3) { /* Strength Dots Container */
            flex-basis: 25%;
            display: flex; /* To use justify-content */
            justify-content: flex-end; /* Align dots to the right */
        }
        
        .prediction-item:last-child {
            border-bottom: none;
        }
        
        .prediction-strength {
            display: flex;
            gap: 5px;
        }
        
        .strength-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--gray);
        }
        
        .strength-dot.active {
            background: var(--success);
        }
        
        footer {
            text-align: center;
            padding: 20px;
            color: var(--gray);
            font-size: 14px;
            border-top: 1px solid var(--border);
            margin-top: 20px;
        }
        
        .indicator-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(37, 99, 235, 0.2);
            color: var(--primary);
        }
        
        @media (max-width: 1200px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .controls {
                width: 100%;
                justify-content: center;
            }
            
            .indicators-grid {
                grid-template-columns: 1fr;
            }
        }

    #logViewContainer {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        max-height: 200px; /* Or your preferred max height */
        background-color: rgba(10, 20, 30, 0.95); /* Dark background */
        border-top: 1px solid var(--border);
        box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
        z-index: 2000; /* Ensure it's above other content */
        display: flex; /* Use flex for layout */
        flex-direction: column; /* Stack header and content vertically */
    }

    #logViewHeader {
        background-color: var(--secondary); /* Slightly different shade or same as card-bg */
        padding: 5px 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--border);
        cursor: grab; /* For potential future drag functionality, or just to indicate it's a panel */
    }

    #logViewHeader span {
        font-weight: bold;
        color: var(--light);
    }

    #logViewHeader button {
        background: var(--primary);
        color: white;
        border: none;
        border-radius: 4px;
        padding: 3px 8px;
        font-size: 12px;
        cursor: pointer;
        margin-left: 5px;
    }

    #logViewHeader button:hover {
        background: var(--primary-dark);
    }

    #logViewContent {
        flex-grow: 1; /* Allow content to take available space */
        overflow-y: auto; /* Scroll for log messages */
        padding: 8px;
        font-family: 'Courier New', Courier, monospace; /* Monospace for logs */
        font-size: 13px; /* Readable log size */
        color: var(--light);
    }

    .log-message {
        padding: 2px 0;
        border-bottom: 1px dotted rgba(255,255,255,0.1);
        white-space: pre-wrap; /* Preserve whitespace and wrap lines */
        word-break: break-all; /* Break long words/strings */
    }

    .log-message.ERROR { color: var(--danger); font-weight: bold; }
    .log-message.WARN { color: var(--warning); }
    .log-message.INFO { color: #60a5fa; /* A lighter blue */ }
    /* .log-message.LOG will use default color (var(--light)) */
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo" id="homeNavLogo" style="cursor: pointer;">
                <i class="fas fa-chart-line"></i>
                <h1>Deriv Market Analytics</h1>
            </div>
            <div class="controls">
                <select class="currency-selector" id="currencySelector">
                    <option value="EUR/USD">EUR/USD</option>
                    <option value="GBP/USD">GBP/USD</option>
                    <option value="USD/JPY" selected>USD/JPY</option>
                    <option value="AUD/USD">AUD/USD</option>
                    <option value="USD/CAD">USD/CAD</option>
                    <option value="BTC/USD">BTC/USD</option>
                    <option value="ETH/USD">ETH/USD</option>
                    <option value="Gold/USD">Gold/USD</option>
                    <option value="Volatility 10 Index">Volatility 10 Index</option>
                    <option value="Volatility 25 Index">Volatility 25 Index</option>
                    <option value="Volatility 50 Index">Volatility 50 Index</option>
                    <option value="Volatility 75 Index">Volatility 75 Index</option>
                    <option value="Volatility 100 Index">Volatility 100 Index</option>
                    <option value="Jump 10 Index">Jump 10 Index</option>
                    <option value="Jump 25 Index">Jump 25 Index</option>
                    <option value="Jump 50 Index">Jump 50 Index</option>
                    <option value="Jump 75 Index">Jump 75 Index</option>
                    <option value="Jump 100 Index">Jump 100 Index</option>
                    <option value="Boom 500 Index">Boom 500 Index</option>
                    <option value="Crash 500 Index">Crash 500 Index</option>
                    <option value="Step Index">Step Index</option>
                </select>
                <button class="btn" id="connectBtn">
                    <i class="fas fa-plug"></i> Connect to API
                </button>
                <button class="btn btn-outline" id="navStrategiesBtn"><i class="fas fa-list-alt"></i> My Strategies</button>
                <button class="btn btn-outline" id="settingsCogBtn"> {/* Added ID here */}
                    <i class="fas fa-cog"></i> Settings
                </button>
                <button id="requestFullSyncBtn" class="btn btn-outline" style="display:none;"><i class="fas fa-sync-alt"></i> Full Sync</button>
            </div>
        </header>
        
        <div id="noDataWarning" style="display:none; color: var(--warning); text-align: center; padding: 8px; background-color: rgba(245, 158, 11, 0.1); border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--warning);">Warning: Data stream may be interrupted. Please check your connection or request a full sync.</div>

        <div id="dashboardView"> <!-- Dashboard View START -->
          <div class="dashboard">
              <div class="main-content">
                  <div class="chart-container">
                    <div class="chart-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="chart-title">Market Price - USD/JPY</div>
                        <div style="display: flex; align-items: center;"> <!-- Wrapper for selectors -->
                            <div class="timeframe-selector">
                                <button class="time-btn" data-timeframe="1M">1min</button>
                                <button class="time-btn active" data-timeframe="5M">5min</button>
                                <button class="time-btn" data-timeframe="10M">10min</button>
                                <button class="time-btn" data-timeframe="15M">15min</button>
                                <button class="time-btn" data-timeframe="30M">30min</button>
                                <button class="time-btn" data-timeframe="1H">1h</button>
                            </div>
                            <div class="chart-type-selector" style="margin-left: 20px;">
                                <label for="chartTypeSelect" style="font-size: 14px; color: var(--gray); margin-right: 5px;">Type:</label>
                                <select id="chartTypeSelect" style="background: var(--dark); border: 1px solid var(--border); border-radius: 6px; padding: 6px 10px; color: var(--light); font-size: 14px;">
                                    <option value="tick">Line</option>
                                    <option value="ohlcv">Candles</option>
                                </select>
                            </div>
                            <div class="ema-selector" style="margin-left: 20px;">
                                <label for="emaSelect" style="font-size: 14px; color: var(--gray); margin-right: 5px;">EMA:</label>
                                <select id="emaSelect" style="background: var(--dark); border: 1px solid var(--border); border-radius: 6px; padding: 6px 10px; color: var(--light); font-size: 14px;">
                                    <option value="none">None</option>
                                    <option value="ema_10">EMA 10</option>
                                    <option value="ema_20">EMA 20</option>
                                    <option value="ema_30">EMA 30</option>
                                    <option value="ema_50">EMA 50</option>
                                    <option value="ema_100">EMA 100</option>
                                    <option value="ema_200">EMA 200</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <canvas id="priceChart"></canvas>
                </div>
                <p id="symbolNote" style="font-size:12px; color:var(--gray); margin-top: 10px; text-align: center; display:none;">
                    Note: For Gold/USD, OHLCV data might be unavailable if 'XAUUSD' is not the correct Deriv API symbol for your account, or if candle data is not provided for it. Please verify the symbol if issues persist.
                </p>

                <div class="analysis-table-container" style="background: var(--card-bg); border-radius: 12px; border: 1px solid var(--border); padding: 20px; margin-top: 20px;">
                    <h2 style="margin-bottom: 15px; font-size: 18px; font-weight: 600;">Analysis Data</h2>
                    <table id="analysisTable" style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Indicator</th>
                                <th style="text-align: right; padding: 8px; border-bottom: 1px solid var(--border);">Value</th>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Signal</th>
                            </tr>
                        </thead>
                        <tbody id="analysisTableBody">
                            <!-- Rows will be dynamically inserted here by JavaScript -->
                        </tbody>
                    </table>
                </div>

                <!-- Live Strategies Panel START -->
                <div id="liveStrategiesPanel" class="indicator-card" style="margin-top: 20px; padding: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h2 style="font-size: 18px; font-weight: 600; color: var(--light);">My Strategies</h2>
                        <button class="btn btn-sm" id="openStrategyModalBtn">
                            <i class="fas fa-plus"></i> Add New Strategy
                        </button>
                    </div>
                    <div id="liveStrategiesListContainer" style="display: flex; flex-direction: column; gap: 15px;">
                        <!-- Strategies will be loaded here by JavaScript -->
                        <!-- Placeholder message if no strategies -->
                        <p style="color: var(--gray); text-align: center;">Loading strategies...</p>
                    </div>
                </div>
                <!-- Live Strategies Panel END -->
            </div>
            
            <div class="sidebar">
                <div class="market-overview">
                    <div class="overview-header">
                        <h2>Market Overview</h2>
                        <div class="price-change change-up">
                            <i class="fas fa-arrow-up"></i>
                            <span>+0.32%</span>
                        </div>
                    </div>
                    <div class="price-display">148.26</div>
                    <div>USD/JPY • Forex</div>
                    
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">24h High</div>
                            <div class="stat-value">148.92</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">24h Low</div>
                            <div class="stat-value">147.85</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">24h Volume</div>
                            <div class="stat-value">$1.24B</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Market Sentiment</div>
                            <div class="stat-value trend-up">Bullish</div>
                        </div>
                    </div>
                </div>
                
                <div class="prediction-card">
                    <div class="prediction-header">
                        <h2>Indicator Predictions</h2>
                    </div>
                    <div class="prediction-content">
                        <div class="prediction-item">
                            <div>RSI (14)</div>
                            <div class="trend-down">Oversold</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot active"></div>
                                <div class="strength-dot"></div>
                            </div>
                        </div>
                        <div class="prediction-item">
                            <div>MACD</div>
                            <div class="trend-up">Bullish</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot active"></div>
                                <div class="strength-dot active"></div>
                            </div>
                        </div>
                        <div class="prediction-item">
                            <div>Bollinger Bands</div>
                            <div>Neutral</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot"></div>
                                <div class="strength-dot"></div>
                            </div>
                        </div>
                        <div class="prediction-item">
                            <div>Stochastic</div>
                            <div class="trend-up">Bullish</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot active"></div>
                                <div class="strength-dot"></div>
                            </div>
                        </div>
                        <div class="prediction-item">
                            <div>Volume</div>
                            <div class="trend-down">Decreasing</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot"></div>
                                <div class="strength-dot"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Deriv Market Analytics Dashboard • Data provided by Deriv API • Real-time market analysis</p>
            <p>This is a demo interface. Connect to Deriv API for live data.</p>
        </footer>

        <div id="settingsModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(15,23,42,0.7); z-index:1000; align-items:center; justify-content:center;">
            <div style="background:var(--card-bg); border-radius:16px; padding:32px 24px; min-width:320px; max-width:90vw; box-shadow:0 8px 32px rgba(0,0,0,0.3); border:1px solid var(--border); position:relative;">
                <button id="closeSettings" style="position:absolute; top:12px; right:12px; background:none; border:none; color:var(--gray); font-size:20px; cursor:pointer;"><i class="fas fa-times"></i></button>
                <h2 style="margin-bottom:18px;">Settings</h2>
                <label for="derivApiToken" style="font-weight:500;">Deriv API Token</label>
                <input id="derivApiToken" type="text" placeholder="Paste your Deriv API token here" style="width:100%; margin:10px 0 18px 0; padding:10px; border-radius:8px; border:1px solid var(--border); background:var(--dark); color:var(--light);">
                <button id="saveSettingsBtn" class="btn" style="width:100%;">Save</button>
                <div id="settingsSavedMsg" style="color:var(--success); margin-top:10px; display:none;">Saved!</div>
            </div>
        </div>
    </div>

   <!-- Strategy Create/Edit Modal (Initially Hidden) -->
   <div id="strategyEditModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(15,23,42,0.85); z-index:1000; align-items:center; justify-content:center; padding:20px;">
       <div style="background:var(--secondary); border-radius:16px; padding:25px 30px; width:100%; max-width:600px; box-shadow:0 8px 32px rgba(0,0,0,0.3); border:1px solid var(--border); position:relative; max-height: 90vh; overflow-y: auto;">
           <button id="closeStrategyEditModalBtn" style="position:absolute; top:15px; right:15px; background:none; border:none; color:var(--gray); font-size:24px; cursor:pointer; line-height: 1;">&times;</button>
           <h2 id="strategyModalTitle" style="margin-bottom:25px; font-size:22px; color:var(--light); text-align:left;">Create New Strategy</h2>

           <!-- Form content reused from strategyBuilderView design -->
           <input type="hidden" id="strategyModalIdInput" value="">

           <div class="form-group" style="margin-bottom:18px;">
               <label for="strategyModalNameInput" style="display:block; margin-bottom:7px; font-weight:500; font-size:0.9em;">Strategy Name</label>
               <input type="text" id="strategyModalNameInput" placeholder="e.g., 'RSI Buy Signal'" style="width:100%; padding:10px 12px; border-radius:8px; border:1px solid var(--border); background:var(--dark); color:var(--light); font-size:0.95em;">
           </div>

           <div class="form-group" style="margin-bottom:18px;">
               <label for="strategyModalDescriptionInput" style="display:block; margin-bottom:7px; font-weight:500; font-size:0.9em;">Description</label>
               <textarea id="strategyModalDescriptionInput" placeholder="Describe the strategy's logic and purpose" style="width:100%; padding:10px 12px; border-radius:8px; border:1px solid var(--border); background:var(--dark); color:var(--light); min-height:70px; font-size:0.95em;"></textarea>
           </div>

           <div class="form-group" style="margin-bottom:18px; display:flex; align-items:center;">
               <input type="checkbox" id="strategyModalIsActiveInput" style="margin-right:10px; width:17px; height:17px; accent-color: var(--primary);">
               <label for="strategyModalIsActiveInput" style="font-weight:500; font-size:0.9em; margin-bottom:0;">Strategy is Active</label>
           </div>

           <fieldset style="border:1px solid var(--border); border-radius:8px; padding:12px 15px; margin-bottom:18px;">
               <legend style="padding:0 8px; font-weight:500; color:var(--gray); font-size:0.85em;">Condition (Single)</legend>
               <div id="strategyModalConditionsContainer" class="condition-item" style="display:flex; gap:10px; align-items:center;">
                   <select id="strategyModalConditionIndicator" class="condition-indicator" style="padding:8px; border-radius:6px; background:var(--dark); color:var(--light); border:1px solid var(--border); flex:1;">
                       <option value="RSI">RSI</option> <option value="MACD">MACD</option> <option value="STOCH">Stochastic</option> <option value="PRICE">Price</option>
                       <option value="EMA10">EMA10</option> <option value="EMA20">EMA20</option> <option value="EMA30">EMA30</option> <option value="EMA50">EMA50</option> <option value="EMA100">EMA100</option> <option value="EMA200">EMA200</option>
                       <option value="CCI">CCI</option> 
                   </select>
                   <select id="strategyModalConditionOperator" class="condition-operator" style="padding:8px; border-radius:6px; background:var(--dark); color:var(--light); border:1px solid var(--border); flex:1;">
                       <option value="<">&lt;</option> <option value="<=">&lt;=</option> <option value="==">==</option> <option value=">=">&gt;=</option> <option value=">">&gt;</option>
                       <option value="CROSS_ABOVE">Crosses Above</option> <option value="CROSS_BELOW">Crosses Below</option>
                   </select>
                   <input type="text" id="strategyModalConditionValue" class="condition-value" placeholder="Value" style="padding:8px; border-radius:6px; background:var(--dark); color:var(--light); border:1px solid var(--border); flex:1;">
               </div>
           </fieldset>
           
           <fieldset style="border:1px solid var(--border); border-radius:8px; padding:12px 15px; margin-bottom:25px;">
               <legend style="padding:0 8px; font-weight:500; color:var(--gray); font-size:0.85em;">Action (Single)</legend>
               <div id="strategyModalActionsContainer" class="action-item" style="display:flex; gap:10px; align-items:center;">
                   <select id="strategyModalActionType" class="action-type" style="padding:8px; border-radius:6px; background:var(--dark); color:var(--light); border:1px solid var(--border); flex:1;">
                       <option value="BUY">BUY</option> <option value="SELL">SELL</option>
                       <option value="NOTIFY_EMAIL">Notify (Email)</option> <option value="NOTIFY_ALERT">Notify (Alert)</option>
                   </select>
                   <input type="text" id="strategyModalActionDetails" class="action-details" placeholder="Action details (e.g., stake, email)" style="padding:8px; border-radius:6px; background:var(--dark); color:var(--light); border:1px solid var(--border); flex:1;">
               </div>
           </fieldset>
           <div style="display:flex; justify-content:flex-end; gap:12px;">
                <button id="cancelStrategyModalBtn" class="btn btn-outline" type="button"><i class="fas fa-times"></i> Cancel</button>
                <button id="saveStrategyModalBtn" class="btn" type="button"><i class="fas fa-save"></i> Save Strategy</button>
           </div>
       </div>
   </div>

    <script>
        let currentSelectedSymbol = ''; // Global variable for the currently selected symbol
        let jsFrontendChartType = 'tick'; // Default chart type
        let cachedApiData = null; // To store the latest API data for redraws
        let inactivityTimer = null; // Timer for WebSocket inactivity
        const INACTIVITY_THRESHOLD_MS = 30000; // 30 seconds

        const analysisTableConfig = [
            { key: 'prices', label: 'Price', precision: 2 }, // 'key' here refers to the data field for the value
            { key: 'rsi', label: 'RSI (14)', precision: 2, signalKey: 'rsi_signal' },
            { key: 'stochastic', label: 'Stochastic (14,3,3)', precision: 2, signalKey: 'stochastic_signal' },
            { key: 'macd', label: 'MACD (12,26,9)', precision: 2, signalKey: 'macd_signal' }, // This is the MACD line
            { key: 'cci_20', label: 'CCI (20)', precision: 2, signalKey: 'cci_20_signal' },
            { key: 'bollinger_upper', label: 'Bollinger Upper', precision: 2 },
            { key: 'bollinger_middle', label: 'Bollinger Middle', precision: 2 },
            { key: 'bollinger_lower', label: 'Bollinger Lower', precision: 2 },
            { key: 'sma_10', label: 'SMA (10)', precision: 2 },
            { key: 'ema_10', label: 'EMA (10)', precision: 2 },
            { key: 'sma_20', label: 'SMA (20)', precision: 2 },
            { key: 'ema_20', label: 'EMA (20)', precision: 2 },
            { key: 'sma_30', label: 'SMA (30)', precision: 2 },
            { key: 'ema_30', label: 'EMA (30)', precision: 2 },
            { key: 'sma_50', label: 'SMA (50)', precision: 2 },
            { key: 'ema_50', label: 'EMA (50)', precision: 2, signalKey: 'price_ema_50_signal' }, // EMA50 will show its own value, and the Price/EMA50 cross signal
            { key: 'sma_100', label: 'SMA (100)', precision: 2 },
            { key: 'ema_100', label: 'EMA (100)', precision: 2 },
            { key: 'sma_200', label: 'SMA (200)', precision: 2 },
            { key: 'ema_200', label: 'EMA (200)', precision: 2 },
            { key: 'volumes', label: 'Volume', precision: 0 }, // Assuming 'volumes' is the key
            { key: 'atr_14', label: 'ATR (14)', precision: 4 }, // Display ATR value itself
            { key: 'atr_volatility_state', label: 'ATR Volatility', isState: true } // Display ATR Volatility State
        ];
        
        function updateAnalysisTable(apiData) {
            const tableBody = document.getElementById('analysisTableBody');
            if (!tableBody) {
                console.error("analysisTableBody not found!");
                return;
            }
            tableBody.innerHTML = ''; // Clear existing rows

            analysisTableConfig.forEach(item => {
                const dataArray = apiData[item.key]; // Value array
                const latestValue = dataArray && dataArray.length > 0 ? dataArray[dataArray.length - 1] : 'N/A';
                const displayValue = typeof latestValue === 'number' ? latestValue.toFixed(item.precision) : latestValue;

                const row = tableBody.insertRow();
                const cellLabel = row.insertCell();
                const cellValue = row.insertCell();
                const cellSignal = row.insertCell(); // New cell for signal

                cellLabel.textContent = item.label;
                cellValue.style.textAlign = 'right'; // Common style for value cell
                cellSignal.textContent = '-'; // Default signal display
                cellSignal.style.color = 'var(--gray)'; // Default signal color

                // Common styling for all cells
                [cellLabel, cellValue, cellSignal].forEach(cell => {
                    cell.style.padding = '8px';
                    cell.style.borderBottom = '1px solid var(--border)';
                });
                 cellSignal.style.textAlign = 'left';


                if (item.isState) { // Handle state display like ATR Volatility
                    const stateValue = apiData[item.key] !== undefined ? apiData[item.key] : 'N/A';
                    cellValue.textContent = stateValue;
                    // Optionally, apply specific styling to the state value itself if needed
                    if (stateValue === 'High') cellValue.style.color = 'var(--warning)';
                    else if (stateValue === 'Low') cellValue.style.color = 'var(--primary)'; // Or another distinct color
                    else cellValue.style.color = 'var(--light)'; // Normal or N/A
                    cellSignal.textContent = '-'; // No signal for state-like items
                } else {
                    // Existing logic for indicators with numerical values and optional signals
                    const dataArray = apiData[item.key];
                    const latestValue = dataArray && dataArray.length > 0 ? dataArray[dataArray.length - 1] : 'N/A';
                    const displayValue = typeof latestValue === 'number' ? latestValue.toFixed(item.precision) : latestValue;
                    cellValue.textContent = displayValue;
                    cellValue.style.color = 'var(--light)'; // Reset color for numerical values

                    if (item.signalKey && apiData[item.signalKey] !== undefined) {
                        const signalValue = apiData[item.signalKey];
                        cellSignal.textContent = signalValue;
                        
                        if (signalValue === 'Buy') {
                            cellSignal.style.color = 'var(--success)';
                        } else if (signalValue === 'Sell') {
                            cellSignal.style.color = 'var(--danger)';
                        } else {
                            cellSignal.style.color = 'var(--gray)';
                        }
                    }
                }
            });
        }

        // Fetch data from Flask API and update charts
        async function fetchMarketData() {
            try {
                const response = await fetch('http://127.0.0.1:5000/api/market_data');
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Data fetch error:', response.status, errorText);
                    setStatus('Data Fetch Error', 'var(--danger)'); // Assuming setStatus is globally available or passed
                    throw new Error(`Failed to fetch market data: ${response.status} ${errorText}`);
                }
                return await response.json();
            } catch (e) {
                console.error('FetchMarketData caught exception:', e.message);
                // Ensure setStatus is called even for network errors caught by try-catch
                if (typeof setStatus === 'function') { // Check if setStatus is defined
                    setStatus('Data Fetch Error', 'var(--danger)');
                }
                throw e; // Re-throw so pollMarketData can catch it
            }
        }

        function updateCharts(apiData, currentSymbol) {
            if (!apiData) {
                console.warn("updateCharts called with no apiData. Skipping chart update.");
                return;
            }
            cachedApiData = apiData; // Cache the data for EMA selector changes

            console.log("--- updateCharts Called ---");
            // console.log("Received apiData (structure snapshot):", JSON.parse(JSON.stringify(apiData))); // Can be verbose

            const chartTypeToRender = jsFrontendChartType;
            const granularitySeconds = apiData.current_granularity_seconds;
            const priceCtx = document.getElementById('priceChart').getContext('2d');

            if (window.priceChartInstance) {
                window.priceChartInstance.destroy();
            }

            let datasets = [];
            let chartLabels = chartTypeToRender === 'ohlcv' ? 
                              (apiData.ohlcv_candles || []).map(c => c.time) : 
                              (apiData.timestamps || []);

            // Main Price Data (Line or Candlestick)
            if (chartTypeToRender === 'ohlcv' && apiData.ohlcv_candles && apiData.ohlcv_candles.length > 0) {
                const ohlcData = apiData.ohlcv_candles.map(candle => ({
                    x: candle.time, o: candle.open, h: candle.high, l: candle.low, c: candle.close
                }));
                datasets.push({
                    type: 'candlestick',
                    label: `${currentSymbol} OHLCV`,
                    data: ohlcData,
                    order: 0, // Ensure price is drawn first
                    color: { up: 'rgba(34, 197, 94, 1)', down: 'rgba(239, 68, 68, 1)', unchanged: 'rgba(148, 163, 184, 1)' }
                });
            } else if (chartTypeToRender === 'tick' && apiData.timestamps && apiData.prices && apiData.timestamps.length > 0) {
                datasets.push({
                    type: 'line',
                    label: `${currentSymbol} Price (Tick)`,
                    data: apiData.prices.map((price, index) => ({x: apiData.timestamps[index], y: price})),
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.3,
                    pointRadius: 0,
                    order: 0
                });
                chartLabels = apiData.timestamps; // Ensure labels are set for tick chart
            } else {
                console.warn("No primary price data (OHLCV or Tick) to display.");
                // Display "No data" message if no datasets can be formed
                priceCtx.clearRect(0, 0, priceCtx.canvas.width, priceCtx.canvas.height);
                priceCtx.fillStyle = 'var(--gray)';
                priceCtx.textAlign = 'center';
                priceCtx.fillText("No data to display for selected chart type/timeframe.", priceCtx.canvas.width / 2, priceCtx.canvas.height / 2);
                return; // Exit if no main data
            }

            // Bollinger Bands
            if (apiData.bollinger_upper && apiData.bollinger_middle && apiData.bollinger_lower && chartLabels.length > 0) {
                const bbTimestamps = chartTypeToRender === 'ohlcv' ? 
                                     (apiData.ohlcv_candles || []).map(c => c.time) : 
                                     (apiData.timestamps || []);

                if (bbTimestamps.length === apiData.bollinger_upper.length) { // Ensure data aligns
                    datasets.push({
                        type: 'line',
                        label: 'Bollinger Upper',
                        data: apiData.bollinger_upper.map((val, index) => ({x: bbTimestamps[index], y: val})),
                        borderColor: 'rgba(255, 165, 0, 0.5)', // Orange, semi-transparent
                        borderWidth: 1.5,
                        pointRadius: 0,
                        fill: false, // No fill for individual band line
                        order: 1 
                    });
                    datasets.push({
                        type: 'line',
                        label: 'Bollinger Middle',
                        data: apiData.bollinger_middle.map((val, index) => ({x: bbTimestamps[index], y: val})),
                        borderColor: 'rgba(255, 165, 0, 0.8)', // Orange, more opaque
                        borderWidth: 1.5,
                        borderDash: [5, 5], // Dashed line for middle
                        pointRadius: 0,
                        fill: false,
                        order: 2
                    });
                    datasets.push({
                        type: 'line',
                        label: 'Bollinger Lower',
                        data: apiData.bollinger_lower.map((val, index) => ({x: bbTimestamps[index], y: val})),
                        borderColor: 'rgba(255, 165, 0, 0.5)', // Orange, semi-transparent
                        borderWidth: 1.5,
                        pointRadius: 0,
                        fill: '-1', // Fill to the previous dataset (Bollinger Middle or Upper if Middle is not visible)
                                     // Or use specific index: fill: datasets.findIndex(ds => ds.label === 'Bollinger Upper')
                        backgroundColor: 'rgba(255, 165, 0, 0.05)', // Light orange fill
                        order: 3
                    });
                } else {
                     console.warn("Bollinger Bands data length mismatch with timestamps. Skipping BB display.");
                }
            }

            // Selectable EMA
            const emaSelector = document.getElementById('emaSelect');
            const selectedEMAKey = emaSelector ? emaSelector.value : 'none';
            if (selectedEMAKey !== 'none' && apiData[selectedEMAKey] && apiData[selectedEMAKey].length > 0 && chartLabels.length > 0) {
                const emaTimestamps = chartTypeToRender === 'ohlcv' ? 
                                     (apiData.ohlcv_candles || []).map(c => c.time) : 
                                     (apiData.timestamps || []);
                if (emaTimestamps.length === apiData[selectedEMAKey].length) {
                    datasets.push({
                        type: 'line',
                        label: selectedEMAKey.toUpperCase().replace('_', ' '),
                        data: apiData[selectedEMAKey].map((val, index) => ({x: emaTimestamps[index], y: val})),
                        borderColor: 'rgba(139, 0, 139, 0.8)', // Dark Magenta
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                        order: 4 // Ensure EMA is drawn on top of BB fill
                    });
                } else {
                    console.warn(`Selected EMA (${selectedEMAKey}) data length mismatch with timestamps. Skipping EMA display.`);
                }
            }
            
            let timeUnit = 'minute';
            if (granularitySeconds >= 86400) timeUnit = 'day';
            else if (granularitySeconds >= 3600) timeUnit = 'hour';

            window.priceChartInstance = new Chart(priceCtx, {
                // Type is dynamically set per dataset, or can be 'line' if primary is line, 'candlestick' if primary is OHLCV.
                // For mixed charts, it's often better to set type per dataset.
                // Defaulting to 'line' here, but individual datasets will override.
                type: chartTypeToRender === 'ohlcv' ? 'candlestick' : 'line', 
                data: {
                    // labels: chartLabels, // Not needed if x values are provided in each dataset point object
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: timeUnit },
                            adapters: { date: { locale: moment.locale() } },
                            grid: { display: false }
                        },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.05)' },
                        }
                    },
                    plugins: {
                        legend: { display: true, labels: { color: 'var(--light)'} },
                        tooltip: { mode: 'index', intersect: false }
                    }
                }
            });
        }

        document.addEventListener('DOMContentLoaded', async function() {
            // --- Log View Functionality ---
            const logViewContainer = document.getElementById('logViewContainer');
            const logViewContent = document.getElementById('logViewContent');
            const toggleLogViewBtn = document.getElementById('toggleLogViewBtn');
            const clearLogViewBtn = document.getElementById('clearLogViewBtn');
            let isLogViewVisible = false;

            function appendToLogView(message, level = 'LOG') {
                if (!logViewContent) return;

                const messageEl = document.createElement('div');
                messageEl.className = 'log-message ' + level.toUpperCase();
                
                const timestamp = new Date().toLocaleTimeString();
                let formattedMessage = `[${timestamp}] [${level.toUpperCase()}] `;

                if (typeof message === 'object') {
                    try {
                        formattedMessage += JSON.stringify(message, null, 2);
                    } catch (e) {
                        formattedMessage += 'Unserializable Object';
                    }
                } else {
                    formattedMessage += message;
                }
                
                messageEl.textContent = formattedMessage;
                logViewContent.appendChild(messageEl);
                logViewContent.scrollTop = logViewContent.scrollHeight; // Auto-scroll to bottom
            }

            if (toggleLogViewBtn && logViewContainer) {
                // Show log view by default for easier debugging during development
                // Change this to false for production if desired.
                isLogViewVisible = true; 
                logViewContainer.style.display = 'flex';
                toggleLogViewBtn.textContent = '_';


                toggleLogViewBtn.addEventListener('click', () => {
                    isLogViewVisible = !isLogViewVisible;
                    if (isLogViewVisible) {
                        logViewContainer.style.display = 'flex';
                        toggleLogViewBtn.textContent = '_'; // Indicate hide
                    } else {
                        logViewContainer.style.display = 'none';
                        toggleLogViewBtn.textContent = '^'; // Indicate show
                    }
                });
            }

            if (clearLogViewBtn && logViewContent) {
                clearLogViewBtn.addEventListener('click', () => {
                    logViewContent.innerHTML = '';
                    appendToLogView('Log cleared.', 'INFO');
                });
            }

            // Hijack console methods
            const originalConsoleLog = console.log;
            const originalConsoleError = console.error;
            const originalConsoleWarn = console.warn;
            const originalConsoleInfo = console.info;

            console.log = function(...args) {
                originalConsoleLog.apply(console, args);
                appendToLogView(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg).join(' '), 'LOG');
            };

            console.error = function(...args) {
                originalConsoleError.apply(console, args);
                appendToLogView(args.map(arg => arg instanceof Error ? arg.stack || arg.message : typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg).join(' '), 'ERROR');
            };

            console.warn = function(...args) {
                originalConsoleWarn.apply(console, args);
                appendToLogView(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg).join(' '), 'WARN');
            };

            console.info = function(...args) {
                originalConsoleInfo.apply(console, args);
                appendToLogView(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg).join(' '), 'INFO');
            };

            // Initial log message to test the view
            console.log("Log view initialized. All console messages will appear here and in the browser console.");
            // --- End Log View Functionality ---

            // Modal Elements
            const strategyEditModal = document.getElementById('strategyEditModal');
            const strategyModalTitle = document.getElementById('strategyModalTitle');
            const strategyModalIdInput = document.getElementById('strategyModalIdInput');
            const strategyModalNameInput = document.getElementById('strategyModalNameInput');
            const strategyModalDescriptionInput = document.getElementById('strategyModalDescriptionInput');
            const strategyModalIsActiveInput = document.getElementById('strategyModalIsActiveInput');
            const strategyModalConditionIndicator = document.getElementById('strategyModalConditionIndicator');
            const strategyModalConditionOperator = document.getElementById('strategyModalConditionOperator');
            const strategyModalConditionValue = document.getElementById('strategyModalConditionValue');
            const strategyModalActionType = document.getElementById('strategyModalActionType');
            const strategyModalActionDetails = document.getElementById('strategyModalActionDetails');
            const closeStrategyEditModalBtn = document.getElementById('closeStrategyEditModalBtn'); 
            const cancelStrategyModalBtn = document.getElementById('cancelStrategyModalBtn'); 
            const saveStrategyModalBtn = document.getElementById('saveStrategyModalBtn');

            // Panel Button
            const openStrategyModalBtn = document.getElementById('openStrategyModalBtn'); 

            // Critical Modal Structure Check
            if (!strategyEditModal || !strategyModalTitle || !strategyModalIdInput || !strategyModalNameInput || 
                !strategyModalDescriptionInput || !strategyModalIsActiveInput || !strategyModalConditionIndicator || 
                !strategyModalConditionOperator || !strategyModalConditionValue || !strategyModalActionType || 
                !strategyModalActionDetails || !closeStrategyEditModalBtn || !cancelStrategyModalBtn || !saveStrategyModalBtn) {
                console.error("[DEBUG] CRITICAL: One or more strategy modal elements are missing. Modal functionality will be impaired.");
                // Optionally, disable buttons that would trigger modal operations if critical parts are missing
                if (openStrategyModalBtn) { // Check if openStrategyModalBtn itself exists before using it
                    openStrategyModalBtn.disabled = true;
                }
                // Use the navHeaderStrategiesBtn from the outer scope, no re-declaration
                if (navHeaderStrategiesBtn) { 
                    navHeaderStrategiesBtn.disabled = true;
                }
            }

            function openModal() {
                if(strategyEditModal) {
                    strategyEditModal.style.display = 'flex';
                } else {
                    console.error("[DEBUG] strategyEditModal element not found, cannot open modal.");
                }
            }
            function closeModal() {
                if(strategyEditModal) {
                    strategyEditModal.style.display = 'none';
                } else {
                    console.error("[DEBUG] strategyEditModal element not found, cannot close modal.");
                }
            }

            if (openStrategyModalBtn) {
                openStrategyModalBtn.addEventListener('click', function() {
                    console.log('[DEBUG] openStrategyModalBtn clicked for new strategy.');
                    // Null checks for modal elements are implicitly covered by the critical check above
                    // or should be handled by the function if it can proceed partially.
                    // For this reset operation, if elements are missing, it's part of the critical failure.
                    if (!strategyModalTitle || !strategyModalIdInput || !strategyModalNameInput || !strategyModalDescriptionInput ||
                        !strategyModalIsActiveInput || !strategyModalConditionIndicator || !strategyModalConditionOperator ||
                        !strategyModalConditionValue || !strategyModalActionType || !strategyModalActionDetails) {
                        console.error("[DEBUG] Cannot reset modal form for new strategy, critical elements missing.");
                        return;
                    }
                    strategyModalTitle.textContent = 'Create New Strategy';
                    strategyModalIdInput.value = ''; 
                    strategyModalNameInput.value = '';
                    strategyModalDescriptionInput.value = '';
                    strategyModalIsActiveInput.checked = true; 
                    strategyModalConditionIndicator.selectedIndex = 0;
                    strategyModalConditionOperator.selectedIndex = 0;
                    strategyModalConditionValue.value = '';
                    strategyModalActionType.selectedIndex = 0;
                    strategyModalActionDetails.value = '';
                    openModal();
                });
            } else {
                console.warn("[DEBUG] Element with ID 'openStrategyModalBtn' not found. Listener not attached.");
            }
            
            if(closeStrategyEditModalBtn) {
                closeStrategyEditModalBtn.addEventListener('click', closeModal);
            } else {
                console.warn("[DEBUG] Element with ID 'closeStrategyEditModalBtn' not found. Listener not attached.");
            }

            if(cancelStrategyModalBtn) {
                cancelStrategyModalBtn.addEventListener('click', closeModal);
            } else {
                console.warn("[DEBUG] Element with ID 'cancelStrategyModalBtn' not found. Listener not attached.");
            }

            if (saveStrategyModalBtn) {
                saveStrategyModalBtn.addEventListener('click', async function() {
                    if (!strategyModalIdInput || !strategyModalNameInput || !strategyModalDescriptionInput || 
                        !strategyModalIsActiveInput || !strategyModalConditionIndicator || !strategyModalConditionOperator || 
                        !strategyModalConditionValue || !strategyModalActionType || !strategyModalActionDetails) {
                        console.error("[DEBUG] CRITICAL: One or more modal form elements are missing. Cannot save strategy.");
                        alert("Error: Strategy form is incomplete. Cannot save.");
                        return;
                    }

                    const strategyId = strategyModalIdInput.value;
                    const strategyName = strategyModalNameInput.value.trim();
                    
                    if (!strategyName) {
                        alert('Strategy Name is required.');
                        return;
                    }

                    const conditionsGroup = {
                        logical_operator: 'AND',
                        conditions: [{
                            indicator: strategyModalConditionIndicator.value,
                            operator: strategyModalConditionOperator.value,
                            value: strategyModalConditionValue.value.trim()
                        }]
                    };
                    // Ensure condition values are somewhat valid before including, or send empty if not.
                    if (!strategyModalConditionIndicator.value || !strategyModalConditionOperator.value || !strategyModalConditionValue.value.trim()) {
                        conditionsGroup.conditions = []; 
                    }

                    let actions = [{ 
                        type: strategyModalActionType.value,
                        details: strategyModalActionDetails.value.trim()
                    }];
                    if (!strategyModalActionType.value) { 
                        actions = []; 
                    }

                    const strategyPayload = {
                        strategy_name: strategyName,
                        description: strategyModalDescriptionInput.value.trim(),
                        is_active: strategyModalIsActiveInput.checked,
                        conditions_group: conditionsGroup,
                        actions: actions
                    };

                    let url = '/api/strategies';
                    let method = 'POST';
                    if (strategyId) { // strategyId is already defined in this scope
                        url = `/api/strategies/${strategyId}`;
                        method = 'PUT';
                    }

                    // Debug logs to be added:
                    console.log(`[DEBUG] Attempting to save strategy.`);
                    console.log(`[DEBUG] Strategy ID: '${strategyId}' (blank if new)`);
                    console.log(`[DEBUG] Method: ${method}`);
                    console.log(`[DEBUG] URL: ${url}`);
                    console.log(`[DEBUG] Payload:`, JSON.stringify(strategyPayload, null, 2)); // Pretty print payload

                    try {
                        const response = await fetch(url, { // This is the existing fetch call
                            method: method,
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(strategyPayload)
                        });
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ detail: 'Unknown error during save.' }));
                            throw new Error(`Failed to save strategy: ${response.status} - ${errorData.detail || errorData.error || 'Server error'}`);
                        }
                        await response.json(); 
                        alert('Strategy saved successfully!');
                        closeModal();
                        loadAndDisplayCustomStrategies(); 
                    } catch (error) {
                        console.error('Error saving strategy from modal:', error);
                        alert(`Could not save strategy: ${error.message}`);
                    }
                });
            }
            
            const navStrategiesBtn = document.getElementById('navStrategiesBtn');
            const navHeaderStrategiesBtn = document.getElementById('navStrategiesBtn'); // Renamed for clarity from general navStrategiesBtn
            if (navHeaderStrategiesBtn) {
                // Assuming previous removeEventListener for 'showView' on 'navStrategiesBtn' was effective or not needed if it wasn't attached.
                navHeaderStrategiesBtn.addEventListener('click', function() {
                    console.log('[DEBUG] Header navStrategiesBtn clicked, opening modal for new strategy.');
                     if (!strategyModalTitle || !strategyModalIdInput || !strategyModalNameInput || !strategyModalDescriptionInput ||
                        !strategyModalIsActiveInput || !strategyModalConditionIndicator || !strategyModalConditionOperator ||
                        !strategyModalConditionValue || !strategyModalActionType || !strategyModalActionDetails) {
                        console.error("[DEBUG] Cannot reset modal form from header button, critical modal elements missing.");
                        return;
                    }
                    strategyModalTitle.textContent = 'Create New Strategy';
                    strategyModalIdInput.value = '';
                    strategyModalNameInput.value = '';
                    strategyModalDescriptionInput.value = '';
                    strategyModalIsActiveInput.checked = true;
                    strategyModalConditionIndicator.selectedIndex = 0;
                    strategyModalConditionOperator.selectedIndex = 0;
                    strategyModalConditionValue.value = '';
                    strategyModalActionType.selectedIndex = 0;
                    strategyModalActionDetails.value = '';
                    openModal();
                });
            } else {
                console.warn("[DEBUG] Element with ID 'navStrategiesBtn' (header button) not found. Listener not attached.");
            }

            // Register financial chart types
            const chartJSLib = typeof Chart !== 'undefined' ? Chart : null; // Check Chart library
            if (chartJSLib && chartJSLib.FinancialController) { 
                 Chart.register(Chart.FinancialController, Chart.OhlcController, Chart.CandlestickController, Chart.OhlcElement, Chart.CandlestickElement);
                 console.log('Financial chart types registered (v0.1.x style).');
            } else if (typeof Chart !== 'undefined' && Chart.controllers && Chart.controllers.candlestick) { // For chartjs-chart-financial v0.2.x+
                 // For v0.2.0 and later, it might auto-register or be part of the main Chart object upon import.
                 // If using <script> tag, it should auto-register.
                 console.log('Financial chart types assumed to be registered (v0.2.x+ style or auto-registered).');
            } else {
                 console.warn('chartjs-chart-financial controllers not found or failed to register. Candlestick charts may not work.');
            }

            // Add connection status indicator
            let connectionStatus = document.createElement('span');
            connectionStatus.id = 'connectionStatus';
            connectionStatus.style.marginLeft = '12px';
            connectionStatus.style.fontWeight = 'bold';
            connectionStatus.style.fontSize = '15px'; // Maintained style
            connectionStatus.style.verticalAlign = 'middle'; // Maintained style
            // Ensure connectBtn is defined before trying to access its parentNode
            const connectBtnMain = document.getElementById('connectBtn'); // Explicitly named
            if (connectBtnMain) {
                 if (connectionStatus) connectBtnMain.parentNode.appendChild(connectionStatus); else console.warn("[DEBUG] connectionStatus span not created, cannot append to connectBtn parent.");
            } else {
                console.warn("[DEBUG] Main connectBtn not found. Status indicator not appended.");
            }

            const currencySelector = document.getElementById('currencySelector');
            const chartTitleElement = document.querySelector('.chart-title'); // querySelector is fine, less critical if missing
            const marketOverviewSymbolElement = document.querySelector('.market-overview div:nth-child(3)'); // Also less critical

            function setStatus(text, color) {
                if (connectionStatus) {
                    connectionStatus.textContent = text;
                    connectionStatus.style.color = color; 
                } else {
                    console.warn("[DEBUG] setStatus called, but connectionStatus element is null.");
                }
            }

            // Initial state
            setStatus("Disconnected", "var(--gray)");
            if (currencySelector) {
                currentSelectedSymbol = currencySelector.value; 
            } else {
                console.warn("[DEBUG] currencySelector not found. Cannot set initial currentSelectedSymbol.");
                currentSelectedSymbol = "USD/JPY"; // Fallback if selector is missing
            }

            if (chartTitleElement) {
                chartTitleElement.textContent = `Market Price - ${currentSelectedSymbol}`;
            } else {
                console.warn("[DEBUG] chartTitleElement not found. Cannot set initial chart title.");
            }
            if(marketOverviewSymbolElement) { 
                marketOverviewSymbolElement.textContent = `${currentSelectedSymbol} • Forex`; 
            } else {
                console.warn("[DEBUG] marketOverviewSymbolElement not found. Cannot set initial overview symbol.");
            }

            if (connectBtnMain) {
                connectBtnMain.innerHTML = '<i class="fas fa-plug"></i> Connect to API';
                connectBtnMain.style.background = 'var(--primary)';
                connectBtnMain.disabled = false; 
            }
            // No else for connectBtnMain here as its absence is warned above.

            // Event listener for currency selector change
            if (currencySelector) {
                currencySelector.addEventListener('change', async function(event) {
                const newSymbolValue = event.target.value;
                const selectedSymbolText = event.target.options[event.target.selectedIndex].text; // Get the display text
                const symbolNoteEl = document.getElementById('symbolNote');

                if (symbolNoteEl) { // Check if element exists
                    if (selectedSymbolText === 'Gold/USD') {
                        symbolNoteEl.style.display = 'block';
                    } else {
                        symbolNoteEl.style.display = 'none';
                    }
                }

                console.log(`Symbol changed to: ${newSymbolValue} (Display: ${selectedSymbolText})`);
                currentSelectedSymbol = newSymbolValue; // Update global symbol

                setStatus(`Switching to ${newSymbolValue}...`, 'var(--warning)');
                currencySelector.disabled = true;

                // Optionally clear charts or show loading state on them
                // For example, clear price display immediately
                document.querySelector('.price-display').textContent = '--';
                // updateCharts({timestamps:[], prices:[], rsi:[], macd:[], bollinger_upper:[], bollinger_middle:[], bollinger_lower:[], stochastic:[], volumes:[]}, newSymbolValue);


                try {
                    const response = await fetch('/api/set_symbol', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ symbol: newSymbolValue })
                    });
                    const result = await response.json();

                    if (response.ok && result.status === 'symbol_updated') {
                        if (chartTitleElement) {
                            chartTitleElement.textContent = `Market Price - ${result.new_symbol}`;
                        }
                        if (marketOverviewSymbolElement) { // Update market overview symbol display
                             marketOverviewSymbolElement.textContent = `${result.new_symbol} • Forex`;
                        }
                        setStatus(`Switched to ${result.new_symbol}`, 'var(--success)');
                        // Data will be updated by the poller. Optionally trigger an immediate poll:
                        // clearTimeout(pollTimeoutId); pollMarketData();
                    } else {
                        const errorMsg = result.message || 'Failed to switch symbol.';
                        console.error('Error switching symbol:', errorMsg);
                        setStatus(`Error: ${errorMsg}`, 'var(--danger)');
                        // Revert selector if needed, or alert user
                        currencySelector.value = currentSelectedSymbol; // Revert to last known good symbol if API call fails
                        currentSelectedSymbol = currencySelector.value; // Ensure global is also reverted
                        alert(`Failed to switch symbol: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Exception when calling /api/set_symbol:', error);
                    setStatus('Symbol switch failed (Network)', 'var(--danger)');
                    currencySelector.value = currentSelectedSymbol; // Revert
                    currentSelectedSymbol = currencySelector.value;
                    alert('Error switching symbol. Check network or backend.');
                } finally {
                    currencySelector.disabled = false;
                }
            });


            // Poll the Python backend for real market data every 2 seconds
            let polling = true;
            let pollTimeoutId = null;
            
            async function pollMarketData() {
                if (!polling) return;
                try {
                    const data = await fetchMarketData();
                    cachedApiData = data; // Cache the data
                    
                    if (data) {
                        // Update price display (use OHLCV close if available, else tick prices)
                        let latestPriceForDisplay = '--';
                        if (jsFrontendChartType === 'ohlcv' && data.ohlcv_candles && data.ohlcv_candles.length > 0) {
                            latestPriceForDisplay = data.ohlcv_candles[data.ohlcv_candles.length - 1].close.toFixed(2);
                        } else if (data.prices && data.prices.length > 0) {
                            latestPriceForDisplay = data.prices[data.prices.length - 1].toFixed(2);
                        }
                        document.querySelector('.price-display').textContent = latestPriceForDisplay;
                        
                        updateCharts(data, currentSelectedSymbol); // Update main price chart
                        updateAnalysisTable(data); // Update the new analysis table

                        // Helper function to update prediction items
                        function updatePredictionItem(indicatorName, state, trendClass) {
                            const items = document.querySelectorAll('.prediction-card .prediction-item');
                            items.forEach(item => {
                                const labelEl = item.querySelector('div:first-child');
                                if (labelEl && labelEl.textContent.includes(indicatorName)) {
                                    const stateEl = item.querySelector('div:nth-child(2)');
                                    if (stateEl) {
                                        stateEl.textContent = state; // Set the text
                                        stateEl.className = ''; // Clear existing classes
                                        stateEl.classList.add('prediction-state-text'); // Add common class
                                        if (trendClass) { // trendClass will now be like 'prediction-state-bullish'
                                            stateEl.classList.add(trendClass);
                                        } else {
                                            stateEl.classList.add('prediction-state-neutral'); // Default if no specific class
                                        }
                                    }
                                }
                            });
                        }

                        // Function to map backend prediction states to frontend display and CSS classes
                        function getPredictionDisplay(state) {
                            let cssClass = 'prediction-state-neutral'; // Default
                            if (state === 'Oversold') cssClass = 'prediction-state-oversold';
                            else if (state === 'Overbought') cssClass = 'prediction-state-overbought';
                            else if (state === 'Bullish') cssClass = 'prediction-state-bullish';
                            else if (state === 'Bearish') cssClass = 'prediction-state-bearish';
                            else if (state === 'Neutral') cssClass = 'prediction-state-neutral';
                            // 'Buy' and 'Sell' signals are typically for the table, prediction states are more descriptive.
                            return { text: state, className: cssClass };
                        }

                        // Update Indicator Predictions Card
                        if (data.rsi_prediction_state !== undefined) {
                            const rsiDisplay = getPredictionDisplay(data.rsi_prediction_state);
                            updatePredictionItem('RSI', rsiDisplay.text, rsiDisplay.className);
                        }
                        if (data.stochastic_prediction_state !== undefined) {
                            const stochDisplay = getPredictionDisplay(data.stochastic_prediction_state);
                            updatePredictionItem('Stochastic', stochDisplay.text, stochDisplay.className);
                        }
                        if (data.macd_prediction_state !== undefined) {
                            const macdDisplay = getPredictionDisplay(data.macd_prediction_state);
                            updatePredictionItem('MACD', macdDisplay.text, macdDisplay.className);
                        }
                        if (data.cci_20_prediction_state !== undefined) {
                            const cciDisplay = getPredictionDisplay(data.cci_20_prediction_state);
                            const items = document.querySelectorAll('.prediction-card .prediction-item');
                            items.forEach(item => {
                                const labelEl = item.querySelector('div:first-child');
                                if (labelEl && labelEl.textContent.startsWith('Bollinger Bands')) { // Still using this to find the CCI row
                                    labelEl.textContent = 'CCI (20)'; 
                                    updatePredictionItem('CCI (20)', cciDisplay.text, cciDisplay.className); 
                                }
                            });
                        }
                        // Note: The 'Volume' prediction item remains static.

                        // Update Market Overview Card
                        const high24hEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(1) .stat-value');
                        if (high24hEl && data.high_24h !== undefined) {
                            high24hEl.textContent = typeof data.high_24h === 'number' ? data.high_24h.toFixed(2) : data.high_24h;
                        }

                        const low24hEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(2) .stat-value');
                        if (low24hEl && data.low_24h !== undefined) {
                            low24hEl.textContent = typeof data.low_24h === 'number' ? data.low_24h.toFixed(2) : data.low_24h;
                        }

                        const volume24hEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(3) .stat-value');
                        if (volume24hEl && data.volume_24h !== undefined) {
                            if (typeof data.volume_24h === 'number') {
                                volume24hEl.textContent = data.volume_24h.toLocaleString();
                            } else {
                                volume24hEl.textContent = data.volume_24h;
                            }
                        }

                        const sentimentEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(4) .stat-value');
                        if (sentimentEl && data.market_sentiment_text !== undefined) {
                            sentimentEl.textContent = data.market_sentiment_text;
                            // Clear existing sentiment classes
                            sentimentEl.classList.remove('sentiment-value-bullish', 'sentiment-value-bearish', 'sentiment-value-neutral', 'trend-up', 'trend-down');
                            if (data.market_sentiment_text === 'Bullish') {
                                sentimentEl.classList.add('sentiment-value-bullish');
                            } else if (data.market_sentiment_text === 'Bearish') {
                                sentimentEl.classList.add('sentiment-value-bearish');
                            } else { // Neutral or N/A
                                sentimentEl.classList.add('sentiment-value-neutral');
                            }
                        }
                        
                        // Status update logic based on connection and data availability
                       if (connectionStatus.textContent.includes("Data") || connectionStatus.textContent.includes("No Data")) {
                           // Assuming if connectBtn says "Connected", we are good.
                           if(connectBtnMain && connectBtnMain.textContent.includes("Connected")) {
                               setStatus('Connected', 'var(--success)');
                           } else if (connectBtnMain && connectBtnMain.textContent.includes("Connect to API")){ // if we are not connected, show neutral
                                setStatus('Disconnected', 'var(--gray)');
                           } else {
                               setStatus('Data Available', 'var(--gray)'); 
                           }
                       }
                    } else {
                         // This case might occur if backend returns empty data but not an error
                        document.querySelector('.price-display').textContent = '--';
                        if(connectBtnMain && connectBtnMain.textContent.includes("Connected")) { // Only show "No Data" if we expect to be connected
                            setStatus('No Data', 'var(--warning)');
                        }
                    }
                } catch (e) {
                    // fetchMarketData already sets "Data Fetch Error", so this is redundant unless it's a different error.
                    console.error("Error in pollMarketData:", e.message);
                    document.querySelector('.price-display').textContent = 'Error';
                     // If polling fails, and we thought we were connected, update status.
                    if (connectBtnMain && connectBtnMain.textContent.includes("Connected")) {
                         setStatus('Data Error', 'var(--danger)');
                    }
                }
                if (polling) { // Check again in case polling was stopped during await
                   pollTimeoutId = setTimeout(pollMarketData, 1000);
                }
            }

            // Initial table setup with N/A values
            const initialEmptyDataForTable = {};
            analysisTableConfig.forEach(item => {
                initialEmptyDataForTable[item.key] = []; // Initialize with empty arrays for indicator values
                if (item.signalKey) {
                    initialEmptyDataForTable[item.signalKey] = 'N/A'; // Initialize signal strings to 'N/A'
                }
            });
            updateAnalysisTable(initialEmptyDataForTable);
            
            // Initialize chart controls and add event listeners
            const chartTypeSelectEl = document.getElementById('chartTypeSelect');
            const timeframeButtons = document.querySelectorAll('.timeframe-selector .time-btn'); // querySelectorAll is fine, returns empty NodeList if not found
            const emaSelectorEl = document.getElementById('emaSelect');

            if (emaSelectorEl) {
                emaSelectorEl.addEventListener('change', function() {
                    if (cachedApiData) { // Only update if we have data
                        console.log("EMA selection changed to:", this.value, "Redrawing chart with cached data.");
                        updateCharts(cachedApiData, currentSelectedSymbol);
                    } else {
                        console.log("EMA selection changed, but no cached data to redraw chart yet.");
                    }
                });
            }

            function setTimeframeButtonsState(disabled) {
                timeframeButtons.forEach(btn => {
                    btn.disabled = disabled;
                    if (disabled) {
                        btn.style.opacity = '0.5'; // Visually indicate disabled state
                        btn.style.cursor = 'not-allowed';
                    } else {
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                    }
                });
            }

            if (chartTypeSelectEl) {
                chartTypeSelectEl.value = 'tick'; // Default to 'tick'
                // Initial state based on default chart type
                if (chartTypeSelectEl.value === 'tick') {
                    setTimeframeButtonsState(true);
                } else {
                    setTimeframeButtonsState(false);
                }

                chartTypeSelectEl.addEventListener('change', function(event) {
                    const newChartType = event.target.value;
                    jsFrontendChartType = newChartType; // Update global JS state
                    console.log(`jsFrontendChartType explicitly set to: ${jsFrontendChartType}`); 

                    const activeTimeframeButton = document.querySelector('.timeframe-selector .time-btn.active');
                    // The default active timeframe is 5M now, so this default should ideally match.
                    const currentTimeframe = activeTimeframeButton ? activeTimeframeButton.dataset.timeframe : '5M'; 
                    
                    if (newChartType === 'tick') {
                        setTimeframeButtonsState(true);
                    } else { // 'ohlcv'
                        setTimeframeButtonsState(false);
                    }
                    
                    console.log(`Chart type changed to: ${newChartType}, current timeframe: ${currentTimeframe}`);
                    setStatus(`Loading ${newChartType === 'ohlcv' ? 'Candlestick' : 'Line'} chart...`, 'var(--warning)');
                    
                    // When chart type changes, we need to inform the backend,
                    // potentially with the currently active timeframe if it's relevant for OHLCV.
                    fetch('/api/set_chart_settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chart_type: newChartType, timeframe_str: currentTimeframe }) 
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            setStatus(`Chart: ${data.current_chart_type}, Granularity: ${data.current_granularity_seconds}s`, 'var(--gray)');
                            // Data will be updated by WebSocket. No need to trigger poll.
                        } else {
                            console.error('Failed to set chart settings:', data.message);
                            setStatus(`Error: ${data.message || 'Chart settings update failed.'}`, 'var(--danger)');
                        }
                    })
                    .catch(error => {
                        console.error('Error setting chart settings:', error);
                        setStatus('Error: Settings update failed (Network).', 'var(--danger)');
                    });
                });
            }

            if (timeframeButtons) {
                timeframeButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        if (this.classList.contains('active')) {
                            return; 
                        }
                        const newTimeframe = this.dataset.timeframe;
                        
                        // When a timeframe button is clicked, it implies OHLCV chart.
                        const chartTypeSelectEl = document.getElementById('chartTypeSelect'); 
                        if (chartTypeSelectEl) { 
                           chartTypeSelectEl.value = 'ohlcv'; // Force dropdown to 'ohlcv'
                           setTimeframeButtonsState(false); // Ensure buttons are enabled
                        }
                        jsFrontendChartType = 'ohlcv'; // Update global JS state
                        console.log(`jsFrontendChartType explicitly set to 'ohlcv' by timeframe button.`);
                        
                        const chartTypeForAPI = 'ohlcv'; // Explicitly use 'ohlcv' for the API call

                        console.log(`Timeframe changed to: ${newTimeframe}, forcing chart type to: ${chartTypeForAPI}`);
                        setStatus(`Loading ${newTimeframe} OHLCV data...`, 'var(--warning)');

                        timeframeButtons.forEach(btn => btn.classList.remove('active'));
                        this.classList.add('active');

                        fetch('/api/set_chart_settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ chart_type: chartTypeForAPI, timeframe_str: newTimeframe })
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'success') {
                                setStatus(`Chart: ${data.current_chart_type}, Granularity: ${data.current_granularity_seconds}s (${newTimeframe})`, 'var(--gray)');
                                // Data will be updated by WebSocket.
                            } else {
                                console.error('Failed to set chart settings:', data.message);
                                setStatus(`Error: ${data.message || 'Chart settings update failed.'}`, 'var(--danger)');
                            }
                        })
                        .catch(error => {
                            console.error('Error setting chart settings:', error);
                            setStatus('Error: Settings update failed (Network).', 'var(--danger)');
                        });
                    });
                });
            }
            
            // Initial check for timeframe buttons based on the default chart type
            if (chartTypeSelectEl && chartTypeSelectEl.value === 'tick') {
                setTimeframeButtonsState(true);
            } else {
                setTimeframeButtonsState(false);
            }
            
            // WebSocket connection logic
            let marketDataSocket = null;
            const wsUrl = `ws://${window.location.hostname}:${window.location.port || (window.location.protocol === 'https:' ? 443 : 80)}/ws/market_data`;
            
            function resetInactivityTimer() {
                if (inactivityTimer) clearTimeout(inactivityTimer);
                const noDataWarningEl = document.getElementById('noDataWarning');
                if (noDataWarningEl) noDataWarningEl.style.display = 'none';
                
                // If connection status was showing the inactivity warning, reset it
                // This check might need to be more robust depending on exact status messages
                if (connectionStatus && connectionStatus.textContent.includes("No data stream")) {
                    setStatus('Real-time updates connected', 'var(--success)'); 
                }

                inactivityTimer = setTimeout(() => {
                    console.warn("No data received from WebSocket for a while. Potential connection issue.");
                    setStatus('No data stream. Check connection.', 'var(--warning)');
                    if (noDataWarningEl) noDataWarningEl.style.display = 'block';
                }, INACTIVITY_THRESHOLD_MS);
            }

            console.log("Attempting to connect to WebSocket at:", wsUrl);

            function connectWebSocket() {
                if (marketDataSocket && (marketDataSocket.readyState === WebSocket.OPEN || marketDataSocket.readyState === WebSocket.CONNECTING)) {
                    console.log("WebSocket already open or connecting.");
                    return;
                }

                marketDataSocket = new WebSocket(wsUrl);

                marketDataSocket.onopen = function(event) {
                    console.log("WebSocket connection established.");
                    setStatus('Real-time updates connected', 'var(--success)');
                    const requestFullSyncBtn = document.getElementById('requestFullSyncBtn');
                    if (requestFullSyncBtn) requestFullSyncBtn.style.display = 'inline-flex';
                    resetInactivityTimer(); // Start inactivity timer on connection
                };

                marketDataSocket.onmessage = function(event) {
                    resetInactivityTimer(); // Reset timer on any message
                    try {
                        const message = JSON.parse(event.data);
                        console.log("Received WebSocket message, type:", message.type);

                        if (message.type === "full") {
                            cachedApiData = message.data;
                            console.log("Full data update processed.");
                        } else if (message.type === "delta") {
                            if (!cachedApiData) {
                                console.error("Delta update received, but no cachedApiData available. Requesting full sync.");
                                if (marketDataSocket && marketDataSocket.readyState === WebSocket.OPEN) {
                                    marketDataSocket.send(JSON.stringify({ type: "request_full_sync" }));
                                }
                                return; // Wait for full sync before processing further
                            }
                            // Apply changes
                            if (message.changes) {
                                for (const key in message.changes) {
                                    cachedApiData[key] = message.changes[key];
                                }
                            }
                            // Apply deletions
                            if (message.deleted_keys) {
                                for (const key of message.deleted_keys) {
                                    delete cachedApiData[key];
                                }
                            }
                            console.log("Delta update processed.");
                        } else {
                            console.warn("Unknown WebSocket message type:", message.type);
                            return; // Do not proceed with UI updates if message type is unknown
                        }
                        
                        // Common UI update logic after processing "full" or "delta"
                        if (cachedApiData) {
                            if (cachedApiData.current_symbol && cachedApiData.current_symbol !== currentSelectedSymbol) {
                                console.log(`Symbol updated via WebSocket: ${cachedApiData.current_symbol}. Updating UI.`);
                                currentSelectedSymbol = cachedApiData.current_symbol;
                                if (currencySelector) currencySelector.value = currentSelectedSymbol;
                                if (chartTitleElement) chartTitleElement.textContent = `Market Price - ${currentSelectedSymbol}`;
                                if (marketOverviewSymbolElement) marketOverviewSymbolElement.textContent = `${currentSelectedSymbol} • Forex`;
                            }

                            let latestPriceForDisplay = '--';
                            if (jsFrontendChartType === 'ohlcv' && cachedApiData.ohlcv_candles && cachedApiData.ohlcv_candles.length > 0) {
                                latestPriceForDisplay = cachedApiData.ohlcv_candles[cachedApiData.ohlcv_candles.length - 1].close.toFixed(2);
                            } else if (cachedApiData.prices && cachedApiData.prices.length > 0) {
                                latestPriceForDisplay = cachedApiData.prices[cachedApiData.prices.length - 1].toFixed(2);
                            }
                            document.querySelector('.price-display').textContent = latestPriceForDisplay;
                            
                            updateCharts(cachedApiData, currentSelectedSymbol);
                            updateAnalysisTable(cachedApiData);

                            // Prediction items and market overview updates (reusing existing logic)
                            function updatePredictionItem(indicatorName, state, trendClass) {
                                const items = document.querySelectorAll('.prediction-card .prediction-item');
                                items.forEach(item => {
                                    const labelEl = item.querySelector('div:first-child');
                                    if (labelEl && labelEl.textContent.includes(indicatorName)) {
                                        const stateEl = item.querySelector('div:nth-child(2)');
                                        if (stateEl) {
                                            stateEl.textContent = state;
                                            stateEl.className = ''; 
                                            stateEl.classList.add('prediction-state-text');
                                            if (trendClass) stateEl.classList.add(trendClass);
                                            else stateEl.classList.add('prediction-state-neutral');
                                        }
                                    }
                                });
                            }
                            function getPredictionDisplay(state) {
                                let cssClass = 'prediction-state-neutral';
                                if (state === 'Oversold') cssClass = 'prediction-state-oversold';
                                else if (state === 'Overbought') cssClass = 'prediction-state-overbought';
                                else if (state === 'Bullish') cssClass = 'prediction-state-bullish';
                                else if (state === 'Bearish') cssClass = 'prediction-state-bearish';
                                else if (state === 'Neutral') cssClass = 'prediction-state-neutral';
                                return { text: state, className: cssClass };
                            }
                            if (cachedApiData.rsi_prediction_state !== undefined) {
                                const rsiDisplay = getPredictionDisplay(cachedApiData.rsi_prediction_state);
                                updatePredictionItem('RSI', rsiDisplay.text, rsiDisplay.className);
                            }
                            if (cachedApiData.stochastic_prediction_state !== undefined) {
                                const stochDisplay = getPredictionDisplay(cachedApiData.stochastic_prediction_state);
                                updatePredictionItem('Stochastic', stochDisplay.text, stochDisplay.className);
                            }
                            if (cachedApiData.macd_prediction_state !== undefined) {
                                const macdDisplay = getPredictionDisplay(cachedApiData.macd_prediction_state);
                                updatePredictionItem('MACD', macdDisplay.text, macdDisplay.className);
                            }
                            if (cachedApiData.cci_20_prediction_state !== undefined) {
                                const cciDisplay = getPredictionDisplay(cachedApiData.cci_20_prediction_state);
                                const items = document.querySelectorAll('.prediction-card .prediction-item');
                                items.forEach(item => {
                                    const labelEl = item.querySelector('div:first-child');
                                    if (labelEl && labelEl.textContent.startsWith('Bollinger Bands')) { 
                                        labelEl.textContent = 'CCI (20)'; 
                                        updatePredictionItem('CCI (20)', cciDisplay.text, cciDisplay.className); 
                                    }
                                });
                            }
                            const high24hEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(1) .stat-value');
                            if (high24hEl && cachedApiData.high_24h !== undefined) high24hEl.textContent = typeof cachedApiData.high_24h === 'number' ? cachedApiData.high_24h.toFixed(2) : cachedApiData.high_24h;
                            const low24hEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(2) .stat-value');
                            if (low24hEl && cachedApiData.low_24h !== undefined) low24hEl.textContent = typeof cachedApiData.low_24h === 'number' ? cachedApiData.low_24h.toFixed(2) : cachedApiData.low_24h;
                            const volume24hEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(3) .stat-value');
                            if (volume24hEl && cachedApiData.volume_24h !== undefined) volume24hEl.textContent = typeof cachedApiData.volume_24h === 'number' ? cachedApiData.volume_24h.toLocaleString() : cachedApiData.volume_24h;
                            const sentimentEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(4) .stat-value');
                            if (sentimentEl && cachedApiData.market_sentiment_text !== undefined) {
                                sentimentEl.textContent = cachedApiData.market_sentiment_text;
                                sentimentEl.classList.remove('sentiment-value-bullish', 'sentiment-value-bearish', 'sentiment-value-neutral', 'trend-up', 'trend-down');
                                if (cachedApiData.market_sentiment_text === 'Bullish') sentimentEl.classList.add('sentiment-value-bullish');
                                else if (cachedApiData.market_sentiment_text === 'Bearish') sentimentEl.classList.add('sentiment-value-bearish');
                                else sentimentEl.classList.add('sentiment-value-neutral');
                            }
                             // Ensure status is updated correctly after processing any valid message
                            setStatus('Real-time updates connected', 'var(--success)');
                        }

                    } catch (e) {
                        console.error("Error processing WebSocket message:", e);
                        setStatus('Error processing data', 'var(--danger)');
                    }
                };

                marketDataSocket.onerror = function(event) {
                    console.error("WebSocket error:", event);
                    setStatus('WebSocket Error', 'var(--danger)');
                    const requestFullSyncBtn = document.getElementById('requestFullSyncBtn');
                    if (requestFullSyncBtn) requestFullSyncBtn.style.display = 'none';
                    if (inactivityTimer) clearTimeout(inactivityTimer);
                    const noDataWarningEl = document.getElementById('noDataWarning');
                    if (noDataWarningEl) noDataWarningEl.style.display = 'none';
                };

                marketDataSocket.onclose = function(event) {
                    console.log("WebSocket connection closed. Code:", event.code, "Reason:", event.reason, "Clean close:", event.wasClean);
                    setStatus('Real-time updates disconnected', 'var(--gray)');
                    const requestFullSyncBtn = document.getElementById('requestFullSyncBtn');
                    if (requestFullSyncBtn) requestFullSyncBtn.style.display = 'none';
                    if (inactivityTimer) clearTimeout(inactivityTimer);
                    const noDataWarningEl = document.getElementById('noDataWarning');
                    if (noDataWarningEl) noDataWarningEl.style.display = 'none';
                    // Attempt to reconnect after a delay
                    setTimeout(connectWebSocket, 5000); // Try to reconnect every 5 seconds
                };
            }
            
            connectWebSocket(); // Initial connection attempt

            // Settings modal elements
            const settingsModal = document.getElementById('settingsModal');
            const settingsCogBtn = document.getElementById('settingsCogBtn'); 
            const closeSettingsBtn = document.getElementById('closeSettings'); // Corrected: This is for settings modal
            const saveSettingsBtn = document.getElementById('saveSettingsBtn'); // Corrected: This is for settings modal
            const derivApiTokenInput = document.getElementById('derivApiToken');
            const settingsSavedMsg = document.getElementById('settingsSavedMsg');

            // Critical Settings Modal Structure Check
            if (!settingsModal || !settingsCogBtn || !closeSettingsBtn || !saveSettingsBtn || !derivApiTokenInput || !settingsSavedMsg) {
                console.error("[DEBUG] CRITICAL: One or more settings modal elements are missing. Settings functionality will be impaired.");
                if(settingsCogBtn) settingsCogBtn.disabled = true; // Example of disabling trigger
            }

            // Request Full Sync Button Event Listener
            const requestFullSyncBtn = document.getElementById('requestFullSyncBtn');
            if (requestFullSyncBtn) {
                requestFullSyncBtn.addEventListener('click', () => {
                    if (marketDataSocket && marketDataSocket.readyState === WebSocket.OPEN) {
                        console.log("Requesting full data synchronization...");
                        marketDataSocket.send(JSON.stringify({ type: "request_full_sync" }));
                        setStatus('Full sync requested...', 'var(--warning)');
                    } else {
                        console.warn("Cannot request full sync, WebSocket is not open.");
                        alert("WebSocket is not connected. Cannot request full sync.");
                    }
                });
            } else {
                console.warn("Element with ID 'requestFullSyncBtn' not found. Listener not attached.");
            }


            // View Switching Elements (mostly for initial setup now)
                        // Update price display (already part of the common UI update logic)
                        // updateCharts, updateAnalysisTable, etc. are already part of common UI update logic
                        
                        // The common UI update logic is now outside the if/else if for message.type
                        // No need to repeat it here.

                    try {
                        // Add your logic here
                    } catch (e) { // This catch is for JSON.parse or message processing logic
                        console.error("Error processing WebSocket message:", e);
                        setStatus('Error processing data', 'var(--danger)');
                    }
                } // End of onmessage

                marketDataSocket.onerror = function(event) {
                    console.error("WebSocket error:", event);
                    setStatus('WebSocket Error', 'var(--danger)');
                    const requestFullSyncBtn = document.getElementById('requestFullSyncBtn');
                    if (requestFullSyncBtn) requestFullSyncBtn.style.display = 'none';
                };

                marketDataSocket.onclose = function(event) {
                    console.log("WebSocket connection closed. Code:", event.code, "Reason:", event.reason, "Clean close:", event.wasClean);
                    setStatus('Real-time updates disconnected', 'var(--gray)');
                    const requestFullSyncBtn = document.getElementById('requestFullSyncBtn');
                    if (requestFullSyncBtn) requestFullSyncBtn.style.display = 'none';
                    // Attempt to reconnect after a delay
                    setTimeout(connectWebSocket, 5000); // Try to reconnect every 5 seconds
                };
            
            
            connectWebSocket(); // Initial connection attempt

            // Settings modal elements
            const settingsModal = document.getElementById('settingsModal');
            const settingsCogBtn = document.getElementById('settingsCogBtn'); 
            const closeSettingsBtn = document.getElementById('closeSettings'); // Corrected: This is for settings modal
            const saveSettingsBtn = document.getElementById('saveSettingsBtn'); // Corrected: This is for settings modal
            const derivApiTokenInput = document.getElementById('derivApiToken');
            const settingsSavedMsg = document.getElementById('settingsSavedMsg');

            // Critical Settings Modal Structure Check
            if (!settingsModal || !settingsCogBtn || !closeSettingsBtn || !saveSettingsBtn || !derivApiTokenInput || !settingsSavedMsg) {
                console.error("[DEBUG] CRITICAL: One or more settings modal elements are missing. Settings functionality will be impaired.");
                if(settingsCogBtn) settingsCogBtn.disabled = true; // Example of disabling trigger
            }


            // View Switching Elements (mostly for initial setup now)
            const dashboardView = document.getElementById('dashboardView');
            // navStrategiesBtn is already defined as navHeaderStrategiesBtn
            const homeNavLogo = document.getElementById('homeNavLogo');
            // createNewStrategyBtn was for the old view, openStrategyModalBtn for the panel is used.

            const mainViews = ['dashboardView']; // Confirmed

            function showView(viewIdToShow) {
                mainViews.forEach(viewId => {
                    const viewElement = document.getElementById(viewId);
                    if (viewElement) {
                        viewElement.style.display = (viewId === viewIdToShow) ? 'block' : 'none';
                    } else {
                        // Warn if the view we intend to show is missing.
                        if (viewId === viewIdToShow) { 
                           console.warn(`[DEBUG] showView: View element not found: ${viewId}. Ensure its HTML is in index.html.`);
                        }
                    }
                });
                // The specific call to loadAndDisplayCustomStrategies for 'strategiesView' is removed,
                // as 'strategiesView' is no longer a main view and strategies are loaded differently.
            }

            function openSettingsModal() {
                derivApiTokenInput.value = localStorage.getItem('derivApiToken') || '';
                settingsModal.style.display = 'flex';
                settingsSavedMsg.style.display = 'none'; // Reset message
            }

            // Event listener for the main "Connect to API" button (which now opens settings)
            if (connectBtnMain) { // connectBtnMain was previously connectBtn
                connectBtnMain.addEventListener('click', function() {
                    openSettingsModal();
                });
            } else {
                console.warn("[DEBUG] Main 'Connect to API' button (connectBtn) not found. Settings modal cannot be opened from it.");
            }
            
            if (settingsCogBtn) {
                settingsCogBtn.addEventListener('click', openSettingsModal);
            } else {
                console.warn("[DEBUG] Element with ID 'settingsCogBtn' not found. Listener not attached.");
            }
            
            if (closeSettingsBtn) { // This is for settings modal
                closeSettingsBtn.addEventListener('click', function() {
                    if(settingsModal) settingsModal.style.display = 'none'; else console.error("[DEBUG] settingsModal not found on closeSettingsBtn click.");
                });
            } else {
                console.warn("[DEBUG] Element with ID 'closeSettings' (for settings modal) not found. Listener not attached.");
            }

            if (saveSettingsBtn) { // This is for settings modal
                saveSettingsBtn.addEventListener('click', async function() {
                    if (!derivApiTokenInput || !settingsSavedMsg || !connectBtnMain || !settingsModal) {
                        console.error("[DEBUG] Critical element(s) for saveSettingsBtn are missing. Aborting save settings.");
                        return;
                    }
                    const token = derivApiTokenInput.value.trim();
                    localStorage.setItem('derivApiToken', token); 
                    
                    settingsSavedMsg.style.display = 'block'; 
                    setTimeout(() => { settingsSavedMsg.style.display = 'none';}, 2000); 

                    setStatus('Connecting...', 'var(--warning)');
                    connectBtnMain.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Connecting...';
                    connectBtnMain.style.background = 'var(--warning)';
                    connectBtnMain.disabled = true;

                    try {
                        const resp = await fetch('http://127.0.0.1:5000/api/connect', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ token })
                        });
                        const result = await resp.json();

                        if (resp.ok && result.status === 'started') {
                            setStatus('Connected', 'var(--success)');
                            connectBtnMain.innerHTML = '<i class="fas fa-check"></i> Connected';
                            connectBtnMain.style.background = 'var(--success)';
                            setTimeout(() => { if (settingsModal) settingsModal.style.display = 'none'; }, 1000);
                        } else {
                            const errorMsg = result.error || `Connection failed (status ${resp.status}). Check token or backend.`;
                            setStatus(errorMsg, 'var(--danger)');
                            connectBtnMain.innerHTML = '<i class="fas fa-plug"></i> Connect to API';
                            connectBtnMain.style.background = 'var(--primary)';
                            alert(`Connection Failed: ${errorMsg}`); 
                        }
                    } catch (e) {
                        console.error('Failed to connect to backend API:', e);
                        setStatus('Connection Error (Backend)', 'var(--danger)');
                        connectBtnMain.innerHTML = '<i class="fas fa-plug"></i> Connect to API';
                        connectBtnMain.style.background = 'var(--primary)';
                        alert('Failed to connect to backend. Is the server running and accessible?');
                    } finally {
                        connectBtnMain.disabled = false;
                    }
                });
            } else {
                 console.warn("[DEBUG] Element with ID 'saveSettingsBtn' not found. Listener not attached.");
            }

            // View Switching Logic for Home/Dashboard
            if (homeNavLogo) {
                homeNavLogo.addEventListener('click', function() {
                    // console.log('[DEBUG] homeNavLogo clicked. Calling showView("dashboardView").'); // Already has debug log
                    showView('dashboardView');
                });
            } else {
                console.warn("[DEBUG] Element with ID 'homeNavLogo' not found. Listener not attached.");
            }

            // Ensure default view state on load (dashboard visible)
            if (dashboardView) {
                 dashboardView.style.display = 'block'; 
                 console.log('[DEBUG] DOMContentLoaded: dashboardView display set to block.');
            } else {
                 console.error('[DEBUG] DOMContentLoaded: dashboardView element not found! Cannot set initial view.');
            }
            // strategiesView and strategyBuilderView are removed, so no need to hide them.

            async function loadAndDisplayCustomStrategies() {
                console.log('[DEBUG] loadAndDisplayCustomStrategies: Rewritten function called (targeting panel).');
                
                const container = document.getElementById('liveStrategiesListContainer');
                if (!container) {
                    console.error('[DEBUG] loadAndDisplayCustomStrategies (Rewritten): CRITICAL - liveStrategiesListContainer element NOT found. Cannot display strategies.');
                    return; 
                }

                container.innerHTML = '<p style="color: var(--gray); text-align:center; padding: 10px;">Loading strategies...</p>';
                console.log('[DEBUG] loadAndDisplayCustomStrategies (Rewritten): "Loading strategies..." message set.');

                try {
                    console.log('[DEBUG] loadAndDisplayCustomStrategies (Rewritten): Attempting to fetch /api/strategies.');
                    const response = await fetch('/api/strategies');
                    console.log('[DEBUG] loadAndDisplayCustomStrategies (Rewritten): Fetch response status:', response.status);

                    if (!response.ok) {
                        let errorText = 'Failed to fetch strategies.';
                        try {
                            errorText = await response.text(); // Try to get more specific error text
                        } catch (textError) {
                            console.warn('[DEBUG] loadAndDisplayCustomStrategies (Rewritten): Could not parse error text from server.', textError);
                        }
                        console.error(`[DEBUG] loadAndDisplayCustomStrategies (Rewritten): API error. Status: ${response.status}, Response: ${errorText}`);
                        throw new Error(`HTTP error! status: ${response.status}. Body: ${errorText}`);
                    }

                    const strategies = await response.json();
                    console.log('[DEBUG] loadAndDisplayCustomStrategies (Rewritten): Strategies fetched successfully:', strategies);
                    
                    container.innerHTML = ''; // Clear loading message

                    if (!strategies || strategies.length === 0) {
                        container.innerHTML = '<p style="color: var(--gray); text-align: center; padding: 10px;">No strategies defined yet. Click "Add New Strategy" to create one.</p>';
                        console.log('[DEBUG] loadAndDisplayCustomStrategies (Rewritten): "No strategies found" message set.');
                    } else {
                        console.log('[DEBUG] loadAndDisplayCustomStrategies (Rewritten): Rendering strategy items. Count:', strategies.length);
                        strategies.forEach((strategy, index) => { // Added index for logging
                            try {
                                // START OF FOR-EACH CALLBACK BODY (now inside try)
                                console.info(`[DEBUG] Processing strategy at index ${index}:`, strategy ? strategy.strategy_name || strategy.strategy_id : 'Unknown strategy');
                                if (!strategy || typeof strategy.strategy_id === 'undefined') {
                                    console.warn(`[DEBUG] loadAndDisplayCustomStrategies (Rewritten): Skipping invalid strategy object at index ${index}:`, strategy);
                                    return; // Skip this iteration
                                }

                                const strategyItemEl = document.createElement('div');
                            strategyItemEl.className = 'strategy-list-item';
                            strategyItemEl.style.border = '1px solid var(--border)';
                            strategyItemEl.style.borderRadius = '8px';
                            strategyItemEl.style.padding = '15px';
                            strategyItemEl.style.backgroundColor = 'rgba(30, 41, 59, 0.3)';

                            let statusText = strategy.is_active ? 'Active' : 'Disabled';
                            let statusColor = strategy.is_active ? 'var(--success)' : 'var(--warning)';
                            // Ensure status_message is a string before using it
                            const statusMessage = (typeof strategy.status_message === 'string' && strategy.status_message) ? strategy.status_message : '';
                            if (statusMessage && statusMessage !== statusText) {
                                if (strategy.is_active && statusMessage === "Active") {
                                    // default is fine
                                } else if (!strategy.is_active && statusMessage === "Disabled by user") {
                                    statusText = 'Disabled';
                                } else { 
                                    statusText = `${strategy.is_active ? 'Active' : 'Disabled'} (${statusMessage})`;
                                }
                            }
                           
                            let conditionsSummary = "No conditions";
                            if (strategy.conditions_group && strategy.conditions_group.conditions && Array.isArray(strategy.conditions_group.conditions) && strategy.conditions_group.conditions.length > 0) {
                                conditionsSummary = strategy.conditions_group.conditions.map(c => `${c.indicator || 'N/A'} ${c.operator || '?'} ${c.value || 'N/A'}`).join(', ');
                                if (conditionsSummary.length > 50) conditionsSummary = conditionsSummary.substring(0, 47) + "...";
                            }

                            let actionsSummary = "No actions";
                            if (strategy.actions && Array.isArray(strategy.actions) && strategy.actions.length > 0) {
                                actionsSummary = strategy.actions.map(a => a.type || 'N/A').join(', ');
                                if (actionsSummary.length > 30) actionsSummary = actionsSummary.substring(0, 27) + "...";
                            }

                            const strategyName = typeof strategy.strategy_name === 'string' && strategy.strategy_name ? strategy.strategy_name : 'Unnamed Strategy';
                            const description = typeof strategy.description === 'string' && strategy.description ? strategy.description : 'No description.';

                            let content = `
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <h5 style="font-size: 1.1em; color: var(--light); margin:0;">${strategyName}</h5>
                                    <span style="font-size: 0.8em; color: ${statusColor}; font-weight: bold;">${statusText.toUpperCase()}</span>
                                </div>
                                <p style="font-size: 0.85em; color: var(--gray); margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${description}">${description}</p>
                                <p style="font-size: 0.8em; color: var(--gray); margin-bottom: 4px;" title="${conditionsSummary}">Conditions: ${conditionsSummary}</p>
                                <p style="font-size: 0.8em; color: var(--gray); margin-bottom: 12px;" title="${actionsSummary}">Actions: ${actionsSummary}</p>
                                <div style="display: flex; justify-content: flex-start; gap: 8px; margin-top: 10px;">`;

                            if (strategy.is_active) {
                                content += `<button class="btn btn-sm btn-outline toggle-strategy-active-btn" data-id="${strategy.strategy_id}" data-action="disable" style="border-color: var(--warning); color: var(--warning);"><i class="fas fa-stop-circle"></i> Stop</button>`;
                            } else {
                                content += `<button class="btn btn-sm btn-outline toggle-strategy-active-btn" data-id="${strategy.strategy_id}" data-action="enable" style="border-color: var(--success); color: var(--success);"><i class="fas fa-play-circle"></i> Run</button>`;
                            }
                           
                            content += `
                                    <button class="btn btn-sm btn-outline edit-strategy-btn" data-id="${strategy.strategy_id}"><i class="fas fa-edit"></i> Edit</button>
                                    <button class="btn btn-sm btn-outline delete-strategy-btn" data-id="${strategy.strategy_id}" style="border-color:var(--danger); color:var(--danger); margin-left: auto;"><i class="fas fa-trash"></i> Delete</button>
                                </div>`;
                           
                            strategyItemEl.innerHTML = content;
                            container.appendChild(strategyItemEl);

                            // Attach event listeners
                            const editBtn = strategyItemEl.querySelector('.edit-strategy-btn');
                            if (editBtn) {
                                editBtn.addEventListener('click', function() {
                                    if (typeof window.openStrategyModalForEdit === 'function') {
                                        window.openStrategyModalForEdit(this.dataset.id);
                                    } else {
                                        console.error('[DEBUG] openStrategyModalForEdit function not found on window.');
                                    }
                                });
                            }

                            const deleteBtn = strategyItemEl.querySelector('.delete-strategy-btn');
                            if (deleteBtn) {
                                deleteBtn.addEventListener('click', function() {
                                    if (typeof window.handleDeleteStrategy === 'function') {
                                        window.handleDeleteStrategy(this.dataset.id);
                                    } else {
                                        console.error('[DEBUG] handleDeleteStrategy function not found on window.');
                                    }
                                });
                            }

                            const toggleBtn = strategyItemEl.querySelector('.toggle-strategy-active-btn');
                            if (toggleBtn) {
                                toggleBtn.addEventListener('click', function() {
                                    if (typeof window.handleToggleStrategyActive === 'function') {
                                        window.handleToggleStrategyActive(this.dataset.id, this.dataset.action);
                                    } else {
                                        console.error('[DEBUG] handleToggleStrategyActive function not found on window.');
                                    }
                                });
                            }
                            // END OF FOR-EACH CALLBACK BODY
                            } catch (e) {
                                console.error(`Error processing strategy item at index ${index}:`, strategy ? strategy.strategy_name || strategy.strategy_id : 'Unknown strategy', e);
                                // Optionally, you could append a placeholder error message to the container for this specific item:
                                // const errorItemEl = document.createElement('div');
                                // errorItemEl.className = 'strategy-list-item log-message ERROR';
                                // errorItemEl.textContent = `Error loading strategy: ${strategy ? strategy.strategy_name || 'Unnamed' : 'Unknown'}. Check logs.`;
                                // container.appendChild(errorItemEl);
                            }
                        });
                    }
                } catch (error) {
                    console.error('[DEBUG] loadAndDisplayCustomStrategies (Rewritten): Error caught:', error.message, error.stack ? error.stack : '(No stack trace)');
                    if (container) { // Ensure container is still valid before trying to update its innerHTML
                        container.innerHTML = `<p style="color: var(--danger); text-align: center; padding: 10px;">Failed to load strategies: ${error.message}</p>`;
                    }
                }
            }

            // Modify navStrategiesBtn event listener to call loadAndDisplayCustomStrategies
            // The navStrategiesBtn listener was updated in the previous step (Subtask 3 of this Stage)
            // to open the modal for new strategy creation. It no longer uses showView.
            // The old logic that directly manipulated styles for strategiesView is confirmed removed.
            
            // --- Globally Accessible Functions (defined within DOMContentLoaded) ---
            window.openStrategyModalForEdit = async function(strategyId) {
                console.log('[DEBUG] openStrategyModalForEdit called for ID:', strategyId);
                if (!strategyId) return;

                // Ensure modal elements are available (they are declared at the top of DOMContentLoaded)
                if (!strategyModalTitle || !strategyModalIdInput || !strategyModalNameInput /* ... add all other modal inputs */) {
                    console.error("[DEBUG] Critical modal elements missing in openStrategyModalForEdit. Cannot proceed.");
                    alert("Error: Modal components are missing.");
                    return;
                }

                try {
                    const response = await fetch(`/api/strategies/${strategyId}`);
                    if (!response.ok) throw new Error(`Failed to fetch strategy: ${response.status}`);
                    const strategy = await response.json();

                    strategyModalTitle.textContent = 'Edit Strategy';
                    strategyModalIdInput.value = strategy.strategy_id;
                    strategyModalNameInput.value = strategy.strategy_name || '';
                    strategyModalDescriptionInput.value = strategy.description || '';
                    strategyModalIsActiveInput.checked = strategy.is_active === undefined ? true : strategy.is_active;

                    if (strategy.conditions_group && strategy.conditions_group.conditions && strategy.conditions_group.conditions.length > 0) {
                        const cond = strategy.conditions_group.conditions[0];
                        strategyModalConditionIndicator.value = cond.indicator || 'RSI';
                        strategyModalConditionOperator.value = cond.operator || '<';
                        strategyModalConditionValue.value = cond.value || '';
                    } else {
                        strategyModalConditionIndicator.selectedIndex = 0;
                        strategyModalConditionOperator.selectedIndex = 0;
                        strategyModalConditionValue.value = '';
                    }
                    if (strategy.actions && strategy.actions.length > 0) {
                        const act = strategy.actions[0];
                        strategyModalActionType.value = act.type || 'BUY';
                        strategyModalActionDetails.value = act.details || '';
                    } else {
                        strategyModalActionType.selectedIndex = 0;
                        strategyModalActionDetails.value = '';
                    }
                    openModal(); // Assumes openModal is defined within this scope
                } catch (error) {
                    console.error('Error fetching strategy for modal editing:', error);
                    alert('Could not load strategy data for editing.');
                }
            };

            window.handleDeleteStrategy = async function(strategyId) {
                console.log('[DEBUG] handleDeleteStrategy called for ID:', strategyId);
                if (!strategyId) {
                    alert("Strategy ID is missing. Cannot delete.");
                    return;
                }
                if (confirm('Are you sure you want to delete this strategy?')) {
                    try {
                        const response = await fetch(`/api/strategies/${strategyId}`, { method: 'DELETE' });
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ detail: 'Unknown error during delete.' }));
                            throw new Error(`Failed to delete strategy: ${response.status} - ${errorData.detail || 'Server error'}`);
                        }
                        alert('Strategy deleted successfully.');
                        loadAndDisplayCustomStrategies(); // Refresh the list
                    } catch (error) {
                        console.error('Error deleting strategy:', error);
                        alert(`Could not delete strategy: ${error.message}`);
                    }
                }
            };

            window.handleToggleStrategyActive = async function(strategyId, action) {
                console.log(`[DEBUG] handleToggleStrategyActive called for ID: ${strategyId}, Action: ${action}`);
                if (!strategyId || !action) {
                    alert("Strategy ID or action is missing. Cannot proceed.");
                    return;
                }
                const endpoint = action === 'enable' ? `/api/strategies/${strategyId}/enable` : `/api/strategies/${strategyId}/disable`;
                try {
                    const response = await fetch(endpoint, { method: 'POST' });
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: `Unknown error during ${action}.` }));
                        throw new Error(`Failed to ${action} strategy: ${response.status} - ${errorData.detail || 'Server error'}`);
                    }
                    // const result = await response.json(); // Contains the updated strategy
                    alert(`Strategy successfully ${action === 'enable' ? 'enabled (run)' : 'disabled (stopped)'}.`);
                    loadAndDisplayCustomStrategies(); // Refresh the list
                } catch (error) {
                    console.error(`Error ${action} strategy:`, error);
                    alert(`Could not ${action} strategy: ${error.message}`);
                }
            };

            // --- End Globally Accessible Functions ---

            // No longer starting polling here. WebSocket connection is initiated by connectWebSocket().

            try {
                console.info("Attempting to load and display custom strategies...");
                loadAndDisplayCustomStrategies(); // Populate the panel on page load
                console.info("Custom strategies loading initiated.");
            } catch (e) {
                console.error("Error calling loadAndDisplayCustomStrategies:", e);
            }
        });
        
        // The old, separate saveSettingsBtn listener is removed as its functionality 
        // is now part of the saveAndConnectBtn logic triggered from connectBtn flow.
        // Utility to get token (can be removed if not used elsewhere)
    
        
</script>
    <div id="logViewContainer" style="display: none; /* Initially hidden, JS can show it */">
        <div id="logViewHeader">
            <span>Console Log</span>
            <button id="toggleLogViewBtn" title="Toggle Log View">-</button>
            <button id="clearLogViewBtn" title="Clear Log">Clear</button>
        </div>
        <div id="logViewContent">
            <!-- Log messages will be appended here -->
        </div>
    </div>
</body>
</html>
