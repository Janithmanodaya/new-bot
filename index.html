<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deriv API Market Analysis Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #0f172a;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1e293b;
            --light: #f8fafc;
            --gray: #94a3b8;
            --card-bg: rgba(15, 23, 42, 0.7);
            --border: rgba(255, 255, 255, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo i {
            font-size: 28px;
            color: var(--primary);
        }
        
        .logo h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(to right, #3b82f6, #60a5fa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .currency-selector {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 15px;
            color: var(--light);
            font-weight: 500;
            min-width: 150px;
        }
        
        .btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }
        
        .btn-outline {
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        
        .btn-outline:hover {
            background: rgba(37, 99, 235, 0.1);
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .main-content {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 20px;
        }
        
        .chart-container {
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border);
            padding: 20px;
            height: 500px;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .chart-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .timeframe-selector {
            display: flex;
            gap: 10px;
        }
        
        .time-btn {
            background: transparent;
            color: var(--gray);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .time-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .indicators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .indicator-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            transition: transform 0.3s ease;
        }
        
        .indicator-card:hover {
            transform: translateY(-5px);
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        .indicator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .indicator-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .indicator-value {
            font-size: 24px;
            font-weight: 700;
        }
        
        .trend-up {
            color: var(--success);
        }
        
        .trend-down {
            color: var(--danger);
        }

        /* Styles for Market Sentiment value */
        .sentiment-value-bullish {
            background-color: rgba(34, 197, 94, 0.2); /* --success with alpha */
            color: var(--success);
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block; /* To allow padding and border-radius */
            font-weight: 600;
        }
        .sentiment-value-bearish {
            background-color: rgba(239, 68, 68, 0.2); /* --danger with alpha */
            color: var(--danger);
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block;
            font-weight: 600;
        }
        .sentiment-value-neutral {
            background-color: rgba(148, 163, 184, 0.2); /* --gray with alpha */
            color: var(--gray);
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block;
            font-weight: 600;
        }

        /* Styles for Prediction States */
        .prediction-state-text { /* Common styling for all prediction states */
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.9em;
            font-weight: 500;
            text-align: center;
            min-width: 80px; /* Ensure consistent width */
            display: inline-block;
        }
        .prediction-state-oversold { /* Bullish connotation */
            background-color: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }
        .prediction-state-overbought { /* Bearish connotation */
            background-color: rgba(239, 68, 68, 0.15);
            color: var(--danger);
        }
        .prediction-state-bullish {
            background-color: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }
        .prediction-state-bearish {
            background-color: rgba(239, 68, 68, 0.15);
            color: var(--danger);
        }
        .prediction-state-neutral {
            background-color: rgba(148, 163, 184, 0.15);
            color: var(--gray);
        }
        
        .indicator-chart {
            height: 100px;
            margin-top: 15px;
        }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .market-overview {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
        }
        
        .overview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .price-display {
            font-size: 32px;
            font-weight: 700;
            margin: 10px 0;
            background: linear-gradient(to right, #3b82f6, #60a5fa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .price-change {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .change-up {
            color: var(--success);
        }
        
        .change-down {
            color: var(--danger);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            margin: 5px 0;
        }
        
        .stat-label {
            color: var(--gray);
            font-size: 14px;
        }
        
        .prediction-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
        }
        
        .prediction-header {
            margin-bottom: 15px;
        }
        
        .prediction-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .prediction-item {
            display: flex;
            justify-content: space-between;
            align-items: center; /* Vertically align items in the center */
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }
        .prediction-item > div:first-child { /* Label RSI, MACD etc. */
            flex-basis: 35%; /* Give it more space */
            text-align: left;
            font-weight: 500;
        }
        .prediction-item > div:nth-child(2) { /* State Text e.g. Oversold */
            flex-basis: 30%; 
            text-align: center; /* The .prediction-state-text already centers its content */
        }
        .prediction-item > div:nth-child(3) { /* Strength Dots Container */
            flex-basis: 25%;
            display: flex; /* To use justify-content */
            justify-content: flex-end; /* Align dots to the right */
        }
        
        .prediction-item:last-child {
            border-bottom: none;
        }
        
        .prediction-strength {
            display: flex;
            gap: 5px;
        }
        
        .strength-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--gray);
        }
        
        .strength-dot.active {
            background: var(--success);
        }
        
        footer {
            text-align: center;
            padding: 20px;
            color: var(--gray);
            font-size: 14px;
            border-top: 1px solid var(--border);
            margin-top: 20px;
        }
        
        .indicator-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(37, 99, 235, 0.2);
            color: var(--primary);
        }
        
        @media (max-width: 1200px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .controls {
                width: 100%;
                justify-content: center;
            }
            
            .indicators-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo" id="homeNavLogo" style="cursor: pointer;">
                <i class="fas fa-chart-line"></i>
                <h1>Deriv Market Analytics</h1>
            </div>
            <div class="controls">
                <select class="currency-selector" id="currencySelector">
                    <option value="EUR/USD">EUR/USD</option>
                    <option value="GBP/USD">GBP/USD</option>
                    <option value="USD/JPY" selected>USD/JPY</option>
                    <option value="AUD/USD">AUD/USD</option>
                    <option value="USD/CAD">USD/CAD</option>
                    <option value="BTC/USD">BTC/USD</option>
                    <option value="ETH/USD">ETH/USD</option>
                    <option value="Gold/USD">Gold/USD</option>
                    <option value="Volatility 10 Index">Volatility 10 Index</option>
                    <option value="Volatility 25 Index">Volatility 25 Index</option>
                    <option value="Volatility 50 Index">Volatility 50 Index</option>
                    <option value="Volatility 75 Index">Volatility 75 Index</option>
                    <option value="Volatility 100 Index">Volatility 100 Index</option>
                    <option value="Jump 10 Index">Jump 10 Index</option>
                    <option value="Jump 25 Index">Jump 25 Index</option>
                    <option value="Jump 50 Index">Jump 50 Index</option>
                    <option value="Jump 75 Index">Jump 75 Index</option>
                    <option value="Jump 100 Index">Jump 100 Index</option>
                    <option value="Boom 500 Index">Boom 500 Index</option>
                    <option value="Crash 500 Index">Crash 500 Index</option>
                    <option value="Step Index">Step Index</option>
                </select>
                <button class="btn" id="connectBtn">
                    <i class="fas fa-plug"></i> Connect to API
                </button>
                <button class="btn btn-outline" id="navStrategiesBtn"><i class="fas fa-list-alt"></i> My Strategies</button>
                <button class="btn btn-outline" id="settingsCogBtn"> {/* Added ID here */}
                    <i class="fas fa-cog"></i> Settings
                </button>
            </div>
        </header>
        
        <div id="dashboardView"> <!-- Dashboard View START -->
          <div class="dashboard">
              <div class="main-content">
                  <div class="chart-container">
                    <div class="chart-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="chart-title">Market Price - USD/JPY</div>
                        <div style="display: flex; align-items: center;"> <!-- Wrapper for selectors -->
                            <div class="timeframe-selector">
                                <button class="time-btn" data-timeframe="1M">1min</button>
                                <button class="time-btn active" data-timeframe="5M">5min</button>
                                <button class="time-btn" data-timeframe="10M">10min</button>
                                <button class="time-btn" data-timeframe="15M">15min</button>
                                <button class="time-btn" data-timeframe="30M">30min</button>
                                <button class="time-btn" data-timeframe="1H">1h</button>
                            </div>
                            <div class="chart-type-selector" style="margin-left: 20px;">
                                <label for="chartTypeSelect" style="font-size: 14px; color: var(--gray); margin-right: 5px;">Type:</label>
                                <select id="chartTypeSelect" style="background: var(--dark); border: 1px solid var(--border); border-radius: 6px; padding: 6px 10px; color: var(--light); font-size: 14px;">
                                    <option value="tick">Line</option>
                                    <option value="ohlcv">Candles</option>
                                </select>
                            </div>
                            <div class="ema-selector" style="margin-left: 20px;">
                                <label for="emaSelect" style="font-size: 14px; color: var(--gray); margin-right: 5px;">EMA:</label>
                                <select id="emaSelect" style="background: var(--dark); border: 1px solid var(--border); border-radius: 6px; padding: 6px 10px; color: var(--light); font-size: 14px;">
                                    <option value="none">None</option>
                                    <option value="ema_10">EMA 10</option>
                                    <option value="ema_20">EMA 20</option>
                                    <option value="ema_30">EMA 30</option>
                                    <option value="ema_50">EMA 50</option>
                                    <option value="ema_100">EMA 100</option>
                                    <option value="ema_200">EMA 200</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <canvas id="priceChart"></canvas>
                </div>
                <p id="symbolNote" style="font-size:12px; color:var(--gray); margin-top: 10px; text-align: center; display:none;">
                    Note: For Gold/USD, OHLCV data might be unavailable if 'XAUUSD' is not the correct Deriv API symbol for your account, or if candle data is not provided for it. Please verify the symbol if issues persist.
                </p>

                <div class="analysis-table-container" style="background: var(--card-bg); border-radius: 12px; border: 1px solid var(--border); padding: 20px; margin-top: 20px;">
                    <h2 style="margin-bottom: 15px; font-size: 18px; font-weight: 600;">Analysis Data</h2>
                    <table id="analysisTable" style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Indicator</th>
                                <th style="text-align: right; padding: 8px; border-bottom: 1px solid var(--border);">Value</th>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border);">Signal</th>
                            </tr>
                        </thead>
                        <tbody id="analysisTableBody">
                            <!-- Rows will be dynamically inserted here by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="sidebar">
                <div class="market-overview">
                    <div class="overview-header">
                        <h2>Market Overview</h2>
                        <div class="price-change change-up">
                            <i class="fas fa-arrow-up"></i>
                            <span>+0.32%</span>
                        </div>
                    </div>
                    <div class="price-display">148.26</div>
                    <div>USD/JPY • Forex</div>
                    
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">24h High</div>
                            <div class="stat-value">148.92</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">24h Low</div>
                            <div class="stat-value">147.85</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">24h Volume</div>
                            <div class="stat-value">$1.24B</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Market Sentiment</div>
                            <div class="stat-value trend-up">Bullish</div>
                        </div>
                    </div>
                </div>
                
                <div class="prediction-card">
                    <div class="prediction-header">
                        <h2>Indicator Predictions</h2>
                    </div>
                    <div class="prediction-content">
                        <div class="prediction-item">
                            <div>RSI (14)</div>
                            <div class="trend-down">Oversold</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot active"></div>
                                <div class="strength-dot"></div>
                            </div>
                        </div>
                        <div class="prediction-item">
                            <div>MACD</div>
                            <div class="trend-up">Bullish</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot active"></div>
                                <div class="strength-dot active"></div>
                            </div>
                        </div>
                        <div class="prediction-item">
                            <div>Bollinger Bands</div>
                            <div>Neutral</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot"></div>
                                <div class="strength-dot"></div>
                            </div>
                        </div>
                        <div class="prediction-item">
                            <div>Stochastic</div>
                            <div class="trend-up">Bullish</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot active"></div>
                                <div class="strength-dot"></div>
                            </div>
                        </div>
                        <div class="prediction-item">
                            <div>Volume</div>
                            <div class="trend-down">Decreasing</div>
                            <div class="prediction-strength">
                                <div class="strength-dot active"></div>
                                <div class="strength-dot"></div>
                                <div class="strength-dot"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="strategiesView" style="display:none; padding: 20px; background: var(--card-bg); border-radius: 12px; border: 1px solid var(--border); margin-bottom: 20px;">
            <h2 style="margin-bottom: 20px; font-size: 22px; font-weight: 600; color: var(--light);">My Custom Strategies</h2>
            <button id="createNewStrategyBtn" class="btn" style="background-color: var(--success); margin-bottom: 20px;">
                <i class="fas fa-plus-circle"></i> Create New Strategy
            </button>
            <div id="strategiesListContainer" style="border: 1px solid var(--border); border-radius: 8px; padding: 15px; min-height: 200px; background-color: var(--secondary);">
                <!-- Strategies will be listed here by JavaScript -->
                <p style="color: var(--gray);">No strategies loaded yet. Click "My Strategies" or use the navigation to load them.</p>
            </div>
        </div>
        
        <footer>
            <p>Deriv Market Analytics Dashboard • Data provided by Deriv API • Real-time market analysis</p>
            <p>This is a demo interface. Connect to Deriv API for live data.</p>
        </footer>

        <div id="settingsModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(15,23,42,0.7); z-index:1000; align-items:center; justify-content:center;">
            <div style="background:var(--card-bg); border-radius:16px; padding:32px 24px; min-width:320px; max-width:90vw; box-shadow:0 8px 32px rgba(0,0,0,0.3); border:1px solid var(--border); position:relative;">
                <button id="closeSettings" style="position:absolute; top:12px; right:12px; background:none; border:none; color:var(--gray); font-size:20px; cursor:pointer;"><i class="fas fa-times"></i></button>
                <h2 style="margin-bottom:18px;">Settings</h2>
                <label for="derivApiToken" style="font-weight:500;">Deriv API Token</label>
                <input id="derivApiToken" type="text" placeholder="Paste your Deriv API token here" style="width:100%; margin:10px 0 18px 0; padding:10px; border-radius:8px; border:1px solid var(--border); background:var(--dark); color:var(--light);">
                <button id="saveSettingsBtn" class="btn" style="width:100%;">Save</button>
                <div id="settingsSavedMsg" style="color:var(--success); margin-top:10px; display:none;">Saved!</div>
            </div>
        </div>
    </div>

    <script>
        let currentSelectedSymbol = ''; // Global variable for the currently selected symbol
        let jsFrontendChartType = 'tick'; // Default chart type
        let cachedApiData = null; // To store the latest API data for redraws

        const analysisTableConfig = [
            { key: 'prices', label: 'Price', precision: 2 }, // 'key' here refers to the data field for the value
            { key: 'rsi', label: 'RSI (14)', precision: 2, signalKey: 'rsi_signal' },
            { key: 'stochastic', label: 'Stochastic (14,3,3)', precision: 2, signalKey: 'stochastic_signal' },
            { key: 'macd', label: 'MACD (12,26,9)', precision: 2, signalKey: 'macd_signal' }, // This is the MACD line
            { key: 'cci_20', label: 'CCI (20)', precision: 2, signalKey: 'cci_20_signal' },
            { key: 'bollinger_upper', label: 'Bollinger Upper', precision: 2 },
            { key: 'bollinger_middle', label: 'Bollinger Middle', precision: 2 },
            { key: 'bollinger_lower', label: 'Bollinger Lower', precision: 2 },
            { key: 'sma_10', label: 'SMA (10)', precision: 2 },
            { key: 'ema_10', label: 'EMA (10)', precision: 2 },
            { key: 'sma_20', label: 'SMA (20)', precision: 2 },
            { key: 'ema_20', label: 'EMA (20)', precision: 2 },
            { key: 'sma_30', label: 'SMA (30)', precision: 2 },
            { key: 'ema_30', label: 'EMA (30)', precision: 2 },
            { key: 'sma_50', label: 'SMA (50)', precision: 2 },
            { key: 'ema_50', label: 'EMA (50)', precision: 2, signalKey: 'price_ema_50_signal' }, // EMA50 will show its own value, and the Price/EMA50 cross signal
            { key: 'sma_100', label: 'SMA (100)', precision: 2 },
            { key: 'ema_100', label: 'EMA (100)', precision: 2 },
            { key: 'sma_200', label: 'SMA (200)', precision: 2 },
            { key: 'ema_200', label: 'EMA (200)', precision: 2 },
            { key: 'volumes', label: 'Volume', precision: 0 }, // Assuming 'volumes' is the key
            { key: 'atr_14', label: 'ATR (14)', precision: 4 }, // Display ATR value itself
            { key: 'atr_volatility_state', label: 'ATR Volatility', isState: true } // Display ATR Volatility State
        ];
        
        function updateAnalysisTable(apiData) {
            const tableBody = document.getElementById('analysisTableBody');
            if (!tableBody) {
                console.error("analysisTableBody not found!");
                return;
            }
            tableBody.innerHTML = ''; // Clear existing rows

            analysisTableConfig.forEach(item => {
                const dataArray = apiData[item.key]; // Value array
                const latestValue = dataArray && dataArray.length > 0 ? dataArray[dataArray.length - 1] : 'N/A';
                const displayValue = typeof latestValue === 'number' ? latestValue.toFixed(item.precision) : latestValue;

                const row = tableBody.insertRow();
                const cellLabel = row.insertCell();
                const cellValue = row.insertCell();
                const cellSignal = row.insertCell(); // New cell for signal

                cellLabel.textContent = item.label;
                cellValue.style.textAlign = 'right'; // Common style for value cell
                cellSignal.textContent = '-'; // Default signal display
                cellSignal.style.color = 'var(--gray)'; // Default signal color

                // Common styling for all cells
                [cellLabel, cellValue, cellSignal].forEach(cell => {
                    cell.style.padding = '8px';
                    cell.style.borderBottom = '1px solid var(--border)';
                });
                 cellSignal.style.textAlign = 'left';


                if (item.isState) { // Handle state display like ATR Volatility
                    const stateValue = apiData[item.key] !== undefined ? apiData[item.key] : 'N/A';
                    cellValue.textContent = stateValue;
                    // Optionally, apply specific styling to the state value itself if needed
                    if (stateValue === 'High') cellValue.style.color = 'var(--warning)';
                    else if (stateValue === 'Low') cellValue.style.color = 'var(--primary)'; // Or another distinct color
                    else cellValue.style.color = 'var(--light)'; // Normal or N/A
                    cellSignal.textContent = '-'; // No signal for state-like items
                } else {
                    // Existing logic for indicators with numerical values and optional signals
                    const dataArray = apiData[item.key];
                    const latestValue = dataArray && dataArray.length > 0 ? dataArray[dataArray.length - 1] : 'N/A';
                    const displayValue = typeof latestValue === 'number' ? latestValue.toFixed(item.precision) : latestValue;
                    cellValue.textContent = displayValue;
                    cellValue.style.color = 'var(--light)'; // Reset color for numerical values

                    if (item.signalKey && apiData[item.signalKey] !== undefined) {
                        const signalValue = apiData[item.signalKey];
                        cellSignal.textContent = signalValue;
                        
                        if (signalValue === 'Buy') {
                            cellSignal.style.color = 'var(--success)';
                        } else if (signalValue === 'Sell') {
                            cellSignal.style.color = 'var(--danger)';
                        } else {
                            cellSignal.style.color = 'var(--gray)';
                        }
                    }
                }
            });
        }

        // Fetch data from Flask API and update charts
        async function fetchMarketData() {
            try {
                const response = await fetch('http://127.0.0.1:5000/api/market_data');
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Data fetch error:', response.status, errorText);
                    setStatus('Data Fetch Error', 'var(--danger)'); // Assuming setStatus is globally available or passed
                    throw new Error(`Failed to fetch market data: ${response.status} ${errorText}`);
                }
                return await response.json();
            } catch (e) {
                console.error('FetchMarketData caught exception:', e.message);
                // Ensure setStatus is called even for network errors caught by try-catch
                if (typeof setStatus === 'function') { // Check if setStatus is defined
                    setStatus('Data Fetch Error', 'var(--danger)');
                }
                throw e; // Re-throw so pollMarketData can catch it
            }
        }

        function updateCharts(apiData, currentSymbol) {
            if (!apiData) {
                console.warn("updateCharts called with no apiData. Skipping chart update.");
                return;
            }
            cachedApiData = apiData; // Cache the data for EMA selector changes

            console.log("--- updateCharts Called ---");
            // console.log("Received apiData (structure snapshot):", JSON.parse(JSON.stringify(apiData))); // Can be verbose

            const chartTypeToRender = jsFrontendChartType;
            const granularitySeconds = apiData.current_granularity_seconds;
            const priceCtx = document.getElementById('priceChart').getContext('2d');

            if (window.priceChartInstance) {
                window.priceChartInstance.destroy();
            }

            let datasets = [];
            let chartLabels = chartTypeToRender === 'ohlcv' ? 
                              (apiData.ohlcv_candles || []).map(c => c.time) : 
                              (apiData.timestamps || []);

            // Main Price Data (Line or Candlestick)
            if (chartTypeToRender === 'ohlcv' && apiData.ohlcv_candles && apiData.ohlcv_candles.length > 0) {
                const ohlcData = apiData.ohlcv_candles.map(candle => ({
                    x: candle.time, o: candle.open, h: candle.high, l: candle.low, c: candle.close
                }));
                datasets.push({
                    type: 'candlestick',
                    label: `${currentSymbol} OHLCV`,
                    data: ohlcData,
                    order: 0, // Ensure price is drawn first
                    color: { up: 'rgba(34, 197, 94, 1)', down: 'rgba(239, 68, 68, 1)', unchanged: 'rgba(148, 163, 184, 1)' }
                });
            } else if (chartTypeToRender === 'tick' && apiData.timestamps && apiData.prices && apiData.timestamps.length > 0) {
                datasets.push({
                    type: 'line',
                    label: `${currentSymbol} Price (Tick)`,
                    data: apiData.prices.map((price, index) => ({x: apiData.timestamps[index], y: price})),
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.3,
                    pointRadius: 0,
                    order: 0
                });
                chartLabels = apiData.timestamps; // Ensure labels are set for tick chart
            } else {
                console.warn("No primary price data (OHLCV or Tick) to display.");
                // Display "No data" message if no datasets can be formed
                priceCtx.clearRect(0, 0, priceCtx.canvas.width, priceCtx.canvas.height);
                priceCtx.fillStyle = 'var(--gray)';
                priceCtx.textAlign = 'center';
                priceCtx.fillText("No data to display for selected chart type/timeframe.", priceCtx.canvas.width / 2, priceCtx.canvas.height / 2);
                return; // Exit if no main data
            }

            // Bollinger Bands
            if (apiData.bollinger_upper && apiData.bollinger_middle && apiData.bollinger_lower && chartLabels.length > 0) {
                const bbTimestamps = chartTypeToRender === 'ohlcv' ? 
                                     (apiData.ohlcv_candles || []).map(c => c.time) : 
                                     (apiData.timestamps || []);

                if (bbTimestamps.length === apiData.bollinger_upper.length) { // Ensure data aligns
                    datasets.push({
                        type: 'line',
                        label: 'Bollinger Upper',
                        data: apiData.bollinger_upper.map((val, index) => ({x: bbTimestamps[index], y: val})),
                        borderColor: 'rgba(255, 165, 0, 0.5)', // Orange, semi-transparent
                        borderWidth: 1.5,
                        pointRadius: 0,
                        fill: false, // No fill for individual band line
                        order: 1 
                    });
                    datasets.push({
                        type: 'line',
                        label: 'Bollinger Middle',
                        data: apiData.bollinger_middle.map((val, index) => ({x: bbTimestamps[index], y: val})),
                        borderColor: 'rgba(255, 165, 0, 0.8)', // Orange, more opaque
                        borderWidth: 1.5,
                        borderDash: [5, 5], // Dashed line for middle
                        pointRadius: 0,
                        fill: false,
                        order: 2
                    });
                    datasets.push({
                        type: 'line',
                        label: 'Bollinger Lower',
                        data: apiData.bollinger_lower.map((val, index) => ({x: bbTimestamps[index], y: val})),
                        borderColor: 'rgba(255, 165, 0, 0.5)', // Orange, semi-transparent
                        borderWidth: 1.5,
                        pointRadius: 0,
                        fill: '-1', // Fill to the previous dataset (Bollinger Middle or Upper if Middle is not visible)
                                     // Or use specific index: fill: datasets.findIndex(ds => ds.label === 'Bollinger Upper')
                        backgroundColor: 'rgba(255, 165, 0, 0.05)', // Light orange fill
                        order: 3
                    });
                } else {
                     console.warn("Bollinger Bands data length mismatch with timestamps. Skipping BB display.");
                }
            }

            // Selectable EMA
            const emaSelector = document.getElementById('emaSelect');
            const selectedEMAKey = emaSelector ? emaSelector.value : 'none';
            if (selectedEMAKey !== 'none' && apiData[selectedEMAKey] && apiData[selectedEMAKey].length > 0 && chartLabels.length > 0) {
                const emaTimestamps = chartTypeToRender === 'ohlcv' ? 
                                     (apiData.ohlcv_candles || []).map(c => c.time) : 
                                     (apiData.timestamps || []);
                if (emaTimestamps.length === apiData[selectedEMAKey].length) {
                    datasets.push({
                        type: 'line',
                        label: selectedEMAKey.toUpperCase().replace('_', ' '),
                        data: apiData[selectedEMAKey].map((val, index) => ({x: emaTimestamps[index], y: val})),
                        borderColor: 'rgba(139, 0, 139, 0.8)', // Dark Magenta
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false,
                        order: 4 // Ensure EMA is drawn on top of BB fill
                    });
                } else {
                    console.warn(`Selected EMA (${selectedEMAKey}) data length mismatch with timestamps. Skipping EMA display.`);
                }
            }
            
            let timeUnit = 'minute';
            if (granularitySeconds >= 86400) timeUnit = 'day';
            else if (granularitySeconds >= 3600) timeUnit = 'hour';

            window.priceChartInstance = new Chart(priceCtx, {
                // Type is dynamically set per dataset, or can be 'line' if primary is line, 'candlestick' if primary is OHLCV.
                // For mixed charts, it's often better to set type per dataset.
                // Defaulting to 'line' here, but individual datasets will override.
                type: chartTypeToRender === 'ohlcv' ? 'candlestick' : 'line', 
                data: {
                    // labels: chartLabels, // Not needed if x values are provided in each dataset point object
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: timeUnit },
                            adapters: { date: { locale: moment.locale() } },
                            grid: { display: false }
                        },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.05)' },
                        }
                    },
                    plugins: {
                        legend: { display: true, labels: { color: 'var(--light)'} },
                        tooltip: { mode: 'index', intersect: false }
                    }
                }
            });
        }

        document.addEventListener('DOMContentLoaded', async function() {
            // Register financial chart types
            if (typeof Chart !== 'undefined' && Chart.FinancialController) { // For chartjs-chart-financial v0.1.x
                 Chart.register(Chart.FinancialController, Chart.OhlcController, Chart.CandlestickController, Chart.OhlcElement, Chart.CandlestickElement);
                 console.log('Financial chart types registered (v0.1.x style).');
            } else if (typeof Chart !== 'undefined' && Chart.controllers && Chart.controllers.candlestick) { // For chartjs-chart-financial v0.2.x+
                 // For v0.2.0 and later, it might auto-register or be part of the main Chart object upon import.
                 // If using <script> tag, it should auto-register.
                 console.log('Financial chart types assumed to be registered (v0.2.x+ style or auto-registered).');
            } else {
                 console.warn('chartjs-chart-financial controllers not found or failed to register. Candlestick charts may not work.');
            }

            // Add connection status indicator
            let connectionStatus = document.createElement('span');
            connectionStatus.id = 'connectionStatus';
            connectionStatus.style.marginLeft = '12px';
            connectionStatus.style.fontWeight = 'bold';
            connectionStatus.style.fontSize = '15px'; // Maintained style
            connectionStatus.style.verticalAlign = 'middle'; // Maintained style
            // Ensure connectBtn is defined before trying to access its parentNode
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                 connectBtn.parentNode.appendChild(connectionStatus);
            }

            const currencySelector = document.getElementById('currencySelector');
            const chartTitleElement = document.querySelector('.chart-title');
            // Assuming there's an element for the symbol in market overview, e.g., with id="marketOverviewSymbol"
            // Let's target the div that contains "USD/JPY • Forex" text.
            // This is fragile; a more specific ID or class would be better.
            const marketOverviewSymbolElement = document.querySelector('.market-overview div:nth-child(3)');


            function setStatus(text, color) {
                connectionStatus.textContent = text;
                connectionStatus.style.color = color; // Use CSS variables for colors
            }

            // Initial state
            setStatus("Disconnected", "var(--gray)");
            currentSelectedSymbol = currencySelector.value; // Initialize global symbol
            if (chartTitleElement) {
                chartTitleElement.textContent = `Market Price - ${currentSelectedSymbol}`;
            }
            if(marketOverviewSymbolElement) { // Update market overview symbol display
                marketOverviewSymbolElement.textContent = `${currentSelectedSymbol} • Forex`; // Assuming all are Forex for now
            }

            // const connectBtn = document.getElementById('connectBtn'); // Already defined above
            if (connectBtn) {
                connectBtn.innerHTML = '<i class="fas fa-plug"></i> Connect to API';
                connectBtn.style.background = 'var(--primary)';
                connectBtn.disabled = false; // Ensure button is enabled initially
            }

            // Event listener for currency selector change
            currencySelector.addEventListener('change', async function(event) {
                const newSymbolValue = event.target.value;
                const selectedSymbolText = event.target.options[event.target.selectedIndex].text; // Get the display text
                const symbolNoteEl = document.getElementById('symbolNote');

                if (symbolNoteEl) { // Check if element exists
                    if (selectedSymbolText === 'Gold/USD') {
                        symbolNoteEl.style.display = 'block';
                    } else {
                        symbolNoteEl.style.display = 'none';
                    }
                }

                console.log(`Symbol changed to: ${newSymbolValue} (Display: ${selectedSymbolText})`);
                currentSelectedSymbol = newSymbolValue; // Update global symbol

                setStatus(`Switching to ${newSymbolValue}...`, 'var(--warning)');
                currencySelector.disabled = true;

                // Optionally clear charts or show loading state on them
                // For example, clear price display immediately
                document.querySelector('.price-display').textContent = '--';
                // updateCharts({timestamps:[], prices:[], rsi:[], macd:[], bollinger_upper:[], bollinger_middle:[], bollinger_lower:[], stochastic:[], volumes:[]}, newSymbolValue);


                try {
                    const response = await fetch('/api/set_symbol', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ symbol: newSymbolValue })
                    });
                    const result = await response.json();

                    if (response.ok && result.status === 'symbol_updated') {
                        if (chartTitleElement) {
                            chartTitleElement.textContent = `Market Price - ${result.new_symbol}`;
                        }
                        if (marketOverviewSymbolElement) { // Update market overview symbol display
                             marketOverviewSymbolElement.textContent = `${result.new_symbol} • Forex`;
                        }
                        setStatus(`Switched to ${result.new_symbol}`, 'var(--success)');
                        // Data will be updated by the poller. Optionally trigger an immediate poll:
                        // clearTimeout(pollTimeoutId); pollMarketData();
                    } else {
                        const errorMsg = result.message || 'Failed to switch symbol.';
                        console.error('Error switching symbol:', errorMsg);
                        setStatus(`Error: ${errorMsg}`, 'var(--danger)');
                        // Revert selector if needed, or alert user
                        currencySelector.value = currentSelectedSymbol; // Revert to last known good symbol if API call fails
                        currentSelectedSymbol = currencySelector.value; // Ensure global is also reverted
                        alert(`Failed to switch symbol: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Exception when calling /api/set_symbol:', error);
                    setStatus('Symbol switch failed (Network)', 'var(--danger)');
                    currencySelector.value = currentSelectedSymbol; // Revert
                    currentSelectedSymbol = currencySelector.value;
                    alert('Error switching symbol. Check network or backend.');
                } finally {
                    currencySelector.disabled = false;
                }
            });


            // Poll the Python backend for real market data every 2 seconds
            let polling = true;
            let pollTimeoutId = null;
            
            async function pollMarketData() {
                if (!polling) return;
                try {
                    const data = await fetchMarketData();
                    cachedApiData = data; // Cache the data
                    
                    if (data) {
                        // Update price display (use OHLCV close if available, else tick prices)
                        let latestPriceForDisplay = '--';
                        if (jsFrontendChartType === 'ohlcv' && data.ohlcv_candles && data.ohlcv_candles.length > 0) {
                            latestPriceForDisplay = data.ohlcv_candles[data.ohlcv_candles.length - 1].close.toFixed(2);
                        } else if (data.prices && data.prices.length > 0) {
                            latestPriceForDisplay = data.prices[data.prices.length - 1].toFixed(2);
                        }
                        document.querySelector('.price-display').textContent = latestPriceForDisplay;
                        
                        updateCharts(data, currentSelectedSymbol); // Update main price chart
                        updateAnalysisTable(data); // Update the new analysis table

                        // Helper function to update prediction items
                        function updatePredictionItem(indicatorName, state, trendClass) {
                            const items = document.querySelectorAll('.prediction-card .prediction-item');
                            items.forEach(item => {
                                const labelEl = item.querySelector('div:first-child');
                                if (labelEl && labelEl.textContent.includes(indicatorName)) {
                                    const stateEl = item.querySelector('div:nth-child(2)');
                                    if (stateEl) {
                                        stateEl.textContent = state; // Set the text
                                        stateEl.className = ''; // Clear existing classes
                                        stateEl.classList.add('prediction-state-text'); // Add common class
                                        if (trendClass) { // trendClass will now be like 'prediction-state-bullish'
                                            stateEl.classList.add(trendClass);
                                        } else {
                                            stateEl.classList.add('prediction-state-neutral'); // Default if no specific class
                                        }
                                    }
                                }
                            });
                        }

                        // Function to map backend prediction states to frontend display and CSS classes
                        function getPredictionDisplay(state) {
                            let cssClass = 'prediction-state-neutral'; // Default
                            if (state === 'Oversold') cssClass = 'prediction-state-oversold';
                            else if (state === 'Overbought') cssClass = 'prediction-state-overbought';
                            else if (state === 'Bullish') cssClass = 'prediction-state-bullish';
                            else if (state === 'Bearish') cssClass = 'prediction-state-bearish';
                            else if (state === 'Neutral') cssClass = 'prediction-state-neutral';
                            // 'Buy' and 'Sell' signals are typically for the table, prediction states are more descriptive.
                            return { text: state, className: cssClass };
                        }

                        // Update Indicator Predictions Card
                        if (data.rsi_prediction_state !== undefined) {
                            const rsiDisplay = getPredictionDisplay(data.rsi_prediction_state);
                            updatePredictionItem('RSI', rsiDisplay.text, rsiDisplay.className);
                        }
                        if (data.stochastic_prediction_state !== undefined) {
                            const stochDisplay = getPredictionDisplay(data.stochastic_prediction_state);
                            updatePredictionItem('Stochastic', stochDisplay.text, stochDisplay.className);
                        }
                        if (data.macd_prediction_state !== undefined) {
                            const macdDisplay = getPredictionDisplay(data.macd_prediction_state);
                            updatePredictionItem('MACD', macdDisplay.text, macdDisplay.className);
                        }
                        if (data.cci_20_prediction_state !== undefined) {
                            const cciDisplay = getPredictionDisplay(data.cci_20_prediction_state);
                            const items = document.querySelectorAll('.prediction-card .prediction-item');
                            items.forEach(item => {
                                const labelEl = item.querySelector('div:first-child');
                                if (labelEl && labelEl.textContent.startsWith('Bollinger Bands')) { // Still using this to find the CCI row
                                    labelEl.textContent = 'CCI (20)'; 
                                    updatePredictionItem('CCI (20)', cciDisplay.text, cciDisplay.className); 
                                }
                            });
                        }
                        // Note: The 'Volume' prediction item remains static.

                        // Update Market Overview Card
                        const high24hEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(1) .stat-value');
                        if (high24hEl && data.high_24h !== undefined) {
                            high24hEl.textContent = typeof data.high_24h === 'number' ? data.high_24h.toFixed(2) : data.high_24h;
                        }

                        const low24hEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(2) .stat-value');
                        if (low24hEl && data.low_24h !== undefined) {
                            low24hEl.textContent = typeof data.low_24h === 'number' ? data.low_24h.toFixed(2) : data.low_24h;
                        }

                        const volume24hEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(3) .stat-value');
                        if (volume24hEl && data.volume_24h !== undefined) {
                            if (typeof data.volume_24h === 'number') {
                                volume24hEl.textContent = data.volume_24h.toLocaleString();
                            } else {
                                volume24hEl.textContent = data.volume_24h;
                            }
                        }

                        const sentimentEl = document.querySelector('.market-overview .stats-grid .stat-card:nth-child(4) .stat-value');
                        if (sentimentEl && data.market_sentiment_text !== undefined) {
                            sentimentEl.textContent = data.market_sentiment_text;
                            // Clear existing sentiment classes
                            sentimentEl.classList.remove('sentiment-value-bullish', 'sentiment-value-bearish', 'sentiment-value-neutral', 'trend-up', 'trend-down');
                            if (data.market_sentiment_text === 'Bullish') {
                                sentimentEl.classList.add('sentiment-value-bullish');
                            } else if (data.market_sentiment_text === 'Bearish') {
                                sentimentEl.classList.add('sentiment-value-bearish');
                            } else { // Neutral or N/A
                                sentimentEl.classList.add('sentiment-value-neutral');
                            }
                        }
                        
                        // Status update logic based on connection and data availability
                       if (connectionStatus.textContent.includes("Data") || connectionStatus.textContent.includes("No Data")) {
                           // Assuming if connectBtn says "Connected", we are good.
                           if(connectBtn && connectBtn.textContent.includes("Connected")) {
                               setStatus('Connected', 'var(--success)');
                           } else if (connectBtn && connectBtn.textContent.includes("Connect to API")){ // if we are not connected, show neutral
                                setStatus('Disconnected', 'var(--gray)');
                           } else {
                               setStatus('Data Available', 'var(--gray)'); 
                           }
                       }
                    } else {
                         // This case might occur if backend returns empty data but not an error
                        document.querySelector('.price-display').textContent = '--';
                        if(connectBtn && connectBtn.textContent.includes("Connected")) { // Only show "No Data" if we expect to be connected
                            setStatus('No Data', 'var(--warning)');
                        }
                    }
                } catch (e) {
                    // fetchMarketData already sets "Data Fetch Error", so this is redundant unless it's a different error.
                    console.error("Error in pollMarketData:", e.message);
                    document.querySelector('.price-display').textContent = 'Error';
                     // If polling fails, and we thought we were connected, update status.
                    if (connectBtn && connectBtn.textContent.includes("Connected")) {
                         setStatus('Data Error', 'var(--danger)');
                    }
                }
                if (polling) { // Check again in case polling was stopped during await
                   pollTimeoutId = setTimeout(pollMarketData, 1000);
                }
            }

            // Initial table setup with N/A values
            const initialEmptyDataForTable = {};
            analysisTableConfig.forEach(item => {
                initialEmptyDataForTable[item.key] = []; // Initialize with empty arrays for indicator values
                if (item.signalKey) {
                    initialEmptyDataForTable[item.signalKey] = 'N/A'; // Initialize signal strings to 'N/A'
                }
            });
            updateAnalysisTable(initialEmptyDataForTable);
            
            // Initialize chart controls and add event listeners
            const chartTypeSelectEl = document.getElementById('chartTypeSelect');
            const timeframeButtons = document.querySelectorAll('.timeframe-selector .time-btn');
            const emaSelectorEl = document.getElementById('emaSelect');

            if (emaSelectorEl) {
                emaSelectorEl.addEventListener('change', function() {
                    if (cachedApiData) { // Only update if we have data
                        console.log("EMA selection changed to:", this.value, "Redrawing chart with cached data.");
                        updateCharts(cachedApiData, currentSelectedSymbol);
                    } else {
                        console.log("EMA selection changed, but no cached data to redraw chart yet.");
                    }
                });
            }

            function setTimeframeButtonsState(disabled) {
                timeframeButtons.forEach(btn => {
                    btn.disabled = disabled;
                    if (disabled) {
                        btn.style.opacity = '0.5'; // Visually indicate disabled state
                        btn.style.cursor = 'not-allowed';
                    } else {
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                    }
                });
            }

            if (chartTypeSelectEl) {
                chartTypeSelectEl.value = 'tick'; // Default to 'tick'
                // Initial state based on default chart type
                if (chartTypeSelectEl.value === 'tick') {
                    setTimeframeButtonsState(true);
                } else {
                    setTimeframeButtonsState(false);
                }

                chartTypeSelectEl.addEventListener('change', function(event) {
                    const newChartType = event.target.value;
                    jsFrontendChartType = newChartType; // Update global JS state
                    console.log(`jsFrontendChartType explicitly set to: ${jsFrontendChartType}`); 

                    const activeTimeframeButton = document.querySelector('.timeframe-selector .time-btn.active');
                    // The default active timeframe is 5M now, so this default should ideally match.
                    const currentTimeframe = activeTimeframeButton ? activeTimeframeButton.dataset.timeframe : '5M'; 
                    
                    if (newChartType === 'tick') {
                        setTimeframeButtonsState(true);
                    } else { // 'ohlcv'
                        setTimeframeButtonsState(false);
                    }
                    
                    console.log(`Chart type changed to: ${newChartType}, current timeframe: ${currentTimeframe}`);
                    setStatus(`Loading ${newChartType === 'ohlcv' ? 'Candlestick' : 'Line'} chart...`, 'var(--warning)');
                    
                    // When chart type changes, we need to inform the backend,
                    // potentially with the currently active timeframe if it's relevant for OHLCV.
                    fetch('/api/set_chart_settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chart_type: newChartType, timeframe_str: currentTimeframe }) 
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            setStatus(`Chart: ${data.current_chart_type}, Granularity: ${data.current_granularity_seconds}s`, 'var(--gray)');
                            // PollMarketData will pick up new data. Optionally trigger immediate poll or clear chart.
                        } else {
                            console.error('Failed to set chart settings:', data.message);
                            setStatus(`Error: ${data.message || 'Chart settings update failed.'}`, 'var(--danger)');
                        }
                    })
                    .catch(error => {
                        console.error('Error setting chart settings:', error);
                        setStatus('Error: Settings update failed (Network).', 'var(--danger)');
                    });
                });
            }

            if (timeframeButtons) {
                timeframeButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        if (this.classList.contains('active')) {
                            return; 
                        }
                        const newTimeframe = this.dataset.timeframe;
                        
                        // When a timeframe button is clicked, it implies OHLCV chart.
                        const chartTypeSelectEl = document.getElementById('chartTypeSelect'); 
                        if (chartTypeSelectEl) { 
                           chartTypeSelectEl.value = 'ohlcv'; // Force dropdown to 'ohlcv'
                           setTimeframeButtonsState(false); // Ensure buttons are enabled
                        }
                        jsFrontendChartType = 'ohlcv'; // Update global JS state
                        console.log(`jsFrontendChartType explicitly set to 'ohlcv' by timeframe button.`);
                        
                        const chartTypeForAPI = 'ohlcv'; // Explicitly use 'ohlcv' for the API call

                        console.log(`Timeframe changed to: ${newTimeframe}, forcing chart type to: ${chartTypeForAPI}`);
                        setStatus(`Loading ${newTimeframe} OHLCV data...`, 'var(--warning)');

                        timeframeButtons.forEach(btn => btn.classList.remove('active'));
                        this.classList.add('active');

                        fetch('/api/set_chart_settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ chart_type: chartTypeForAPI, timeframe_str: newTimeframe })
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'success') {
                                setStatus(`Chart: ${data.current_chart_type}, Granularity: ${data.current_granularity_seconds}s (${newTimeframe})`, 'var(--gray)');
                            } else {
                                console.error('Failed to set chart settings:', data.message);
                                setStatus(`Error: ${data.message || 'Chart settings update failed.'}`, 'var(--danger)');
                            }
                        })
                        .catch(error => {
                            console.error('Error setting chart settings:', error);
                            setStatus('Error: Settings update failed (Network).', 'var(--danger)');
                        });
                    });
                });
            }
            
            // Initial check for timeframe buttons based on the default chart type
            if (chartTypeSelectEl && chartTypeSelectEl.value === 'tick') {
                setTimeframeButtonsState(true);
            } else {
                setTimeframeButtonsState(false);
            }
            
            pollMarketData(); // Start polling


            // Settings modal elements
            const settingsModal = document.getElementById('settingsModal');
            const settingsCogBtn = document.getElementById('settingsCogBtn'); // Use new ID
            const closeSettingsBtn = document.getElementById('closeSettings');
            const saveAndConnectBtn = document.getElementById('saveSettingsBtn');
            const derivApiTokenInput = document.getElementById('derivApiToken');
            const settingsSavedMsg = document.getElementById('settingsSavedMsg');

            // View Switching Elements
            const dashboardView = document.getElementById('dashboardView');
            const strategiesView = document.getElementById('strategiesView'); 
            const strategyBuilderView = document.getElementById('strategyBuilderView'); // Added
            const navStrategiesBtn = document.getElementById('navStrategiesBtn');
            const homeNavLogo = document.getElementById('homeNavLogo');
            const createNewStrategyBtn = document.getElementById('createNewStrategyBtn');
            // const createNewStrategyBtn = document.getElementById('createNewStrategyBtn'); // Added // This was a duplicate comment from a previous step

            const mainViews = ['dashboardView', 'strategiesView', 'strategyBuilderView'];

            function showView(viewIdToShow) {
                mainViews.forEach(viewId => {
                    const viewElement = document.getElementById(viewId);
                    if (viewElement) {
                        viewElement.style.display = (viewId === viewIdToShow) ? 'block' : 'none';
                    } else {
                        // Warn if the view we intend to show, or a primary alternative view, is missing.
                        if (viewId === viewIdToShow || viewId === 'strategiesView' || viewId === 'strategyBuilderView') {
                           console.warn(`View element not found: ${viewId}. Ensure its HTML is in index.html.`);
                        }
                    }
                });

                if (viewIdToShow === 'strategiesView' && typeof loadAndDisplayCustomStrategies === 'function') {
                    loadAndDisplayCustomStrategies();
                }
                // Example for future:
                // if (viewIdToShow === 'strategyBuilderView' && typeof initializeStrategyBuilder === 'function') {
                //    initializeStrategyBuilder(); 
                // }
            }

            function openSettingsModal() {
                derivApiTokenInput.value = localStorage.getItem('derivApiToken') || '';
                settingsModal.style.display = 'flex';
                settingsSavedMsg.style.display = 'none'; // Reset message
            }

            // Event listener for the "Connect to API" button (main button, not cog)
            if (connectBtn) {
                connectBtn.addEventListener('click', function() {
                    // If already connected, clicking it could show settings or disconnect.
                    // For now, it will always open settings modal to change token or re-connect.
                    openSettingsModal();
                });
            }
            
            // Event listener for the actual "Settings" cog button
            if (settingsCogBtn) {
                settingsCogBtn.addEventListener('click', openSettingsModal);
            }
            
            // Close settings modal
            if (closeSettingsBtn) {
                closeSettingsBtn.addEventListener('click', function() {
                    settingsModal.style.display = 'none';
                });
            }

            // Handle "Save" button in Settings Modal (which also connects)
            if (saveAndConnectBtn) {
                saveAndConnectBtn.addEventListener('click', async function() {
                    const token = derivApiTokenInput.value.trim();
                    localStorage.setItem('derivApiToken', token); // Save token locally
                    
                    settingsSavedMsg.style.display = 'block'; // Show "Saved!" message
                    setTimeout(() => { settingsSavedMsg.style.display = 'none';}, 2000); // Hide after 2s regardless of connection outcome

                    setStatus('Connecting...', 'var(--warning)');
                    if (connectBtn) {
                        connectBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Connecting...';
                        connectBtn.style.background = 'var(--warning)';
                        connectBtn.disabled = true;
                    }

                    try {
                        const resp = await fetch('http://127.0.0.1:5000/api/connect', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ token })
                        });
                        const result = await resp.json();

                        if (resp.ok && result.status === 'started') {
                            setStatus('Connected', 'var(--success)');
                            if (connectBtn) {
                                connectBtn.innerHTML = '<i class="fas fa-check"></i> Connected';
                                connectBtn.style.background = 'var(--success)';
                            }
                            // Close modal on successful connection after a short delay for "Saved!" msg
                            setTimeout(() => { if (settingsModal) settingsModal.style.display = 'none'; }, 1000);
                        } else {
                            const errorMsg = result.error || `Connection failed (status ${resp.status}). Check token or backend.`;
                            setStatus(errorMsg, 'var(--danger)');
                            if (connectBtn) {
                                connectBtn.innerHTML = '<i class="fas fa-plug"></i> Connect to API';
                                connectBtn.style.background = 'var(--primary)';
                            }
                            alert(`Connection Failed: ${errorMsg}`); // Show error in alert
                        }
                    } catch (e) {
                        console.error('Failed to connect to backend API:', e);
                        setStatus('Connection Error (Backend)', 'var(--danger)');
                        if (connectBtn) {
                            connectBtn.innerHTML = '<i class="fas fa-plug"></i> Connect to API';
                            connectBtn.style.background = 'var(--primary)';
                        }
                        alert('Failed to connect to backend. Is the server running and accessible?');
                    } finally {
                        if (connectBtn) {
                            connectBtn.disabled = false;
                        }
                    }
                });
            }

            // View Switching Logic
            if (navStrategiesBtn) {
                navStrategiesBtn.addEventListener('click', function() {
                    // The showView function already checks for element existence and calls loadAndDisplayCustomStrategies
                    showView('strategiesView');
                    console.log("Switched to Strategies View via navStrategiesBtn");
                });
            }

            if (homeNavLogo) {
                homeNavLogo.addEventListener('click', function() {
                    // The showView function already checks for element existence
                    showView('dashboardView');
                    console.log("Switched to Dashboard View via homeNavLogo");
                });
            }

            // Initial view state on page load
            showView('dashboardView'); // This will show dashboardView and hide others, including strategiesView

            // Event Listener for "Create New Strategy" button
            if (createNewStrategyBtn) {
                createNewStrategyBtn.addEventListener('click', async function() {
                    const strategyName = prompt("Enter a name for your new strategy:");

                    if (!strategyName || strategyName.trim() === "") {
                        alert("Strategy name cannot be empty. Creation cancelled.");
                        return;
                    }

                    const strategySymbol = currentSelectedSymbol || 'USD/JPY'; // Use global or default

                    const newStrategyData = {
                        strategy_name: strategyName.trim(),
                        description: `Basic strategy for ${strategySymbol} created from UI.`,
                        conditions_group: {
                            logic: "AND",
                            conditions: [
                                {
                                    indicator: "RSI",
                                    period: 14,
                                    operator: "<",
                                    value: 30,
                                    symbol: strategySymbol
                                }
                            ]
                        },
                        actions: [
                            {
                                type: "BUY", // Or "RISE" if using Deriv contract types directly
                                amount: 10, // Example amount
                                currency: "USD" // Example currency
                            }
                        ]
                    };

                    try {
                        const response = await fetch('/api/strategies', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(newStrategyData),
                        });

                        if (response.ok && response.status === 201) {
                            alert('Strategy "' + strategyName + '" created successfully!');
                            if (typeof loadAndDisplayCustomStrategies === 'function') {
                                loadAndDisplayCustomStrategies(); // Refresh the list
                            }
                        } else {
                            const errorData = await response.json().catch(() => null); // Try to parse error, but don't fail if no body
                            const errorMessage = errorData ? errorData.message || JSON.stringify(errorData) : `HTTP error ${response.status}`;
                            alert(`Failed to create strategy: ${errorMessage}`);
                        }
                    } catch (error) {
                        console.error('Error creating new strategy:', error);
                        alert('Failed to create strategy due to a network or script error: ' + error.message);
                    }
                });
            } else {
                console.warn("createNewStrategyBtn not found during DOMContentLoaded. Cannot attach listener.");
            }

            async function handleDeleteStrategy(strategyId) {
                if (!strategyId) {
                    alert("Strategy ID is missing. Cannot delete.");
                    return;
                }

                const userConfirmed = confirm(`Are you sure you want to delete strategy ID: ${strategyId}?`);
                if (!userConfirmed) {
                    console.log("User cancelled strategy deletion.");
                    return;
                }

                console.log(`Proceeding with deletion for strategy ID: ${strategyId}`);

                try {
                    const response = await fetch(`/api/strategies/${strategyId}`, {
                        method: 'DELETE',
                    });

                    if (response.ok) { // Handles 200 OK or 204 No Content
                        alert('Strategy deleted successfully!');
                        if (typeof loadAndDisplayCustomStrategies === 'function') {
                            loadAndDisplayCustomStrategies(); // Refresh the list
                        }
                    } else {
                        // Try to parse error message from backend if available
                        const errorData = await response.json().catch(() => null); // Avoids error if response is not JSON
                        const errorMessage = errorData ? (errorData.message || JSON.stringify(errorData)) : `HTTP error ${response.status}`;
                        console.error(`Failed to delete strategy ${strategyId}. Status: ${response.status}, Message: ${errorMessage}`);
                        alert(`Failed to delete strategy: ${errorMessage}`);
                    }
                } catch (error) {
                    console.error('Error during strategy deletion fetch:', error);
                    alert('Failed to delete strategy due to a network or script error: ' + error.message);
                }
            }

            async function loadAndDisplayCustomStrategies() {
                const container = document.getElementById('strategiesListContainer');
                if (!container) {
                    console.error('strategiesListContainer element not found. Cannot display strategies.');
                    return;
                }
                container.innerHTML = '<p style="color: var(--gray);">Loading strategies...</p>';

                try {
                    const response = await fetch('/api/strategies');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}, message: ${await response.text()}`);
                    }
                    const strategies = await response.json();
                    container.innerHTML = ''; // Clear loading message

                    if (strategies.length === 0) {
                        container.innerHTML = '<p style="color: var(--gray);">No strategies found. Click the "Create New Strategy" button to start.</p>';
                    } else {
                        strategies.forEach(strategy => {
                            const strategyEl = document.createElement('div');
                            strategyEl.className = 'strategy-item';
                            strategyEl.style.border = '1px solid var(--border)';
                            strategyEl.style.borderRadius = '8px';
                            strategyEl.style.padding = '15px';
                            strategyEl.style.marginBottom = '15px';
                            strategyEl.style.backgroundColor = 'rgba(30, 41, 59, 0.3)'; // Slightly different background for item

                            // Strategy Name
                            const nameEl = document.createElement('h4');
                            nameEl.style.marginBottom = '5px';
                            nameEl.style.color = 'var(--light)';
                            nameEl.textContent = strategy.strategy_name;
                            strategyEl.appendChild(nameEl);

                            // Symbol (if available)
                            if (strategy.symbol) {
                                const symbolEl = document.createElement('p');
                                symbolEl.style.fontSize = '0.9em';
                                symbolEl.style.color = 'var(--gray)';
                                symbolEl.textContent = `Symbol: ${strategy.symbol}`;
                                strategyEl.appendChild(symbolEl);
                            }

                            // Description
                            const descriptionEl = document.createElement('p');
                            descriptionEl.style.fontSize = '0.9em';
                            descriptionEl.style.marginBottom = '10px';
                            descriptionEl.style.color = 'var(--light)';
                            descriptionEl.textContent = strategy.description || 'No description provided.';
                            strategyEl.appendChild(descriptionEl);
                            
                            // Conditions
                            const conditionsTitle = document.createElement('p');
                            conditionsTitle.style.fontSize = '0.85em';
                            conditionsTitle.style.color = 'var(--gray)';
                            conditionsTitle.style.marginTop = '10px';
                            conditionsTitle.style.fontWeight = '600';
                            conditionsTitle.textContent = 'Conditions:';
                            strategyEl.appendChild(conditionsTitle);

                            const conditionsPre = document.createElement('pre');
                            conditionsPre.style.fontSize = '0.75em';
                            conditionsPre.style.color = 'var(--gray)';
                            conditionsPre.style.backgroundColor = 'rgba(0,0,0,0.2)';
                            conditionsPre.style.padding = '5px';
                            conditionsPre.style.borderRadius = '4px';
                            conditionsPre.style.whiteSpace = 'pre-wrap'; // Ensure content wraps
                            conditionsPre.textContent = JSON.stringify(strategy.conditions_group, null, 2);
                            strategyEl.appendChild(conditionsPre);

                            // Actions
                            const actionsTitle = document.createElement('p');
                            actionsTitle.style.fontSize = '0.85em';
                            actionsTitle.style.color = 'var(--gray)';
                            actionsTitle.style.marginTop = '5px';
                            actionsTitle.style.fontWeight = '600';
                            actionsTitle.textContent = 'Actions:';
                            strategyEl.appendChild(actionsTitle);

                            const actionsPre = document.createElement('pre');
                            actionsPre.style.fontSize = '0.75em';
                            actionsPre.style.color = 'var(--gray)';
                            actionsPre.style.backgroundColor = 'rgba(0,0,0,0.2)';
                            actionsPre.style.padding = '5px';
                            actionsPre.style.borderRadius = '4px';
                            actionsPre.style.whiteSpace = 'pre-wrap';
                            actionsPre.textContent = JSON.stringify(strategy.actions, null, 2);
                            strategyEl.appendChild(actionsPre);

                            // Buttons container
                            const buttonsDiv = document.createElement('div');
                            buttonsDiv.style.marginTop = '15px';
                            buttonsDiv.style.display = 'flex';
                            buttonsDiv.style.gap = '10px';

                            // Edit Button
                            const editButton = document.createElement('button');
                            editButton.className = 'btn btn-sm'; // Using btn-sm for smaller padding
                            editButton.textContent = 'Edit';
                            editButton.style.padding = '5px 10px'; // Custom padding for "sm" effect
                            editButton.style.fontSize = '0.8em';
                            editButton.style.backgroundColor = 'transparent';
                            editButton.style.border = '1px solid var(--gray)';
                            editButton.style.color = 'var(--gray)';
                            editButton.addEventListener('click', () => {
                                alert('Edit functionality for strategy ID ' + strategy.strategy_id + ' will be implemented later.');
                            });
                            buttonsDiv.appendChild(editButton);

                            // Delete Button
                            const deleteButton = document.createElement('button');
                            deleteButton.className = 'btn btn-sm';
                            deleteButton.textContent = 'Delete';
                            deleteButton.style.padding = '5px 10px';
                            deleteButton.style.fontSize = '0.8em';
                            deleteButton.style.backgroundColor = 'transparent';
                            deleteButton.style.border = '1px solid var(--danger)';
                            deleteButton.style.color = 'var(--danger)';
                            deleteButton.addEventListener('click', () => {
                                // Pass strategy.strategy_id if available, otherwise a fallback like strategy.strategy_name
                                handleDeleteStrategy(strategy.strategy_id || strategy.strategy_name);
                            });
                            buttonsDiv.appendChild(deleteButton);
                            
                            strategyEl.appendChild(buttonsDiv);
                            container.appendChild(strategyEl);
                        });
                    }
                } catch (error) {
                    console.error('Failed to load strategies:', error);
                    container.innerHTML = `<p style="color: var(--danger);">Failed to load strategies. Details: ${error.message}. Please try again later.</p>`;
                }
            }

            // Modify navStrategiesBtn event listener to call loadAndDisplayCustomStrategies
            // This is handled by showView('strategiesView') calling loadAndDisplayCustomStrategies
            // No duplicate listener needed here. The one above that calls showView is sufficient.

        });
        
        // The old, separate saveSettingsBtn listener is removed as its functionality 
        // is now part of the saveAndConnectBtn logic triggered from connectBtn flow.
        // Utility to get token (can be removed if not used elsewhere)
        // function getDerivApiToken() {
        
    </script>
</body>
</body>
</html>
